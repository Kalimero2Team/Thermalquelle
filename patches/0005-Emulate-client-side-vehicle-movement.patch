From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AJ Ferguson <AJ-Ferguson@users.noreply.github.com>
Date: Fri, 24 May 2024 15:41:00 +0200
Subject: [PATCH] Emulate client side vehicle movement

(Upstream PR: https://github.com/GeyserMC/Geyser/pull/4648)

diff --git a/core/src/main/java/org/geysermc/geyser/entity/EntityDefinitions.java b/core/src/main/java/org/geysermc/geyser/entity/EntityDefinitions.java
index 21cc526dd7a96a221883790481bb4adb501e59b4..474ccdcfb1c1a20339e1d7306974550e5f30fa8d 100644
--- a/core/src/main/java/org/geysermc/geyser/entity/EntityDefinitions.java
+++ b/core/src/main/java/org/geysermc/geyser/entity/EntityDefinitions.java
@@ -860,7 +860,7 @@ public final class EntityDefinitions {
                     .type(EntityType.PIG)
                     .heightAndWidth(0.9f)
                     .addTranslator(MetadataType.BOOLEAN, (pigEntity, entityMetadata) -> pigEntity.setFlag(EntityFlag.SADDLED, ((BooleanEntityMetadata) entityMetadata).getPrimitiveValue()))
-                    .addTranslator(null) // Boost time
+                    .addTranslator(MetadataType.INT, PigEntity::setBoost)
                     .build();
             POLAR_BEAR = EntityDefinition.inherited(PolarBearEntity::new, ageableEntityBase)
                     .type(EntityType.POLAR_BEAR)
@@ -886,7 +886,7 @@ public final class EntityDefinitions {
             STRIDER = EntityDefinition.inherited(StriderEntity::new, ageableEntityBase)
                     .type(EntityType.STRIDER)
                     .height(1.7f).width(0.9f)
-                    .addTranslator(null) // Boost time
+                    .addTranslator(MetadataType.INT, StriderEntity::setBoost)
                     .addTranslator(MetadataType.BOOLEAN, StriderEntity::setCold)
                     .addTranslator(MetadataType.BOOLEAN, StriderEntity::setSaddled)
                     .build();
@@ -927,7 +927,7 @@ public final class EntityDefinitions {
                     .type(EntityType.CAMEL)
                     .height(2.375f).width(1.7f)
                     .addTranslator(MetadataType.BOOLEAN, CamelEntity::setDashing)
-                    .addTranslator(null) // Last pose change tick
+                    .addTranslator(MetadataType.LONG, CamelEntity::setLastPoseTick)
                     .build();
             HORSE = EntityDefinition.inherited(HorseEntity::new, abstractHorseEntityBase)
                     .type(EntityType.HORSE)
diff --git a/core/src/main/java/org/geysermc/geyser/entity/type/Entity.java b/core/src/main/java/org/geysermc/geyser/entity/type/Entity.java
index 6267ee7914cca88f2312e2260e3914950341b00b..43d881d9e252b64c6fdc74dd97d5038a9c513840 100644
--- a/core/src/main/java/org/geysermc/geyser/entity/type/Entity.java
+++ b/core/src/main/java/org/geysermc/geyser/entity/type/Entity.java
@@ -40,6 +40,7 @@ import org.geysermc.geyser.api.entity.type.GeyserEntity;
 import org.geysermc.geyser.entity.EntityDefinition;
 import org.geysermc.geyser.entity.GeyserDirtyMetadata;
 import org.geysermc.geyser.entity.properties.GeyserEntityPropertyManager;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.translator.text.MessageTranslator;
 import org.geysermc.geyser.util.EntityUtils;
@@ -222,6 +223,13 @@ public class Entity implements GeyserEntity {
     }
 
     public void moveRelative(double relX, double relY, double relZ, float yaw, float pitch, float headYaw, boolean isOnGround) {
+        if (this instanceof ClientVehicle clientVehicle) {
+            if (clientVehicle.isClientControlled()) {
+                return;
+            }
+            clientVehicle.getVehicleComponent().moveRelative(relX, relY, relZ);
+        }
+
         position = Vector3f.from(position.getX() + relX, position.getY() + relY, position.getZ() + relZ);
 
         MoveEntityDeltaPacket moveEntityPacket = new MoveEntityDeltaPacket();
@@ -457,6 +465,10 @@ public class Entity implements GeyserEntity {
             dirtyMetadata.put(EntityDataTypes.HEIGHT, boundingBoxHeight);
 
             updatePassengerOffsets();
+
+            if (valid && this instanceof ClientVehicle clientVehicle) {
+                clientVehicle.getVehicleComponent().setHeight(boundingBoxHeight);
+            }
             return true;
         }
         return false;
@@ -466,6 +478,10 @@ public class Entity implements GeyserEntity {
         if (width != boundingBoxWidth) {
             boundingBoxWidth = width;
             dirtyMetadata.put(EntityDataTypes.WIDTH, boundingBoxWidth);
+
+            if (valid && this instanceof ClientVehicle clientVehicle) {
+                clientVehicle.getVehicleComponent().setWidth(boundingBoxWidth);
+            }
         }
     }
 
diff --git a/core/src/main/java/org/geysermc/geyser/entity/type/LivingEntity.java b/core/src/main/java/org/geysermc/geyser/entity/type/LivingEntity.java
index 499084555c4d7c566cde3b143e7d95cc1c48face..064a6b4e58cd8c24f19612034e5f993d140d58f8 100644
--- a/core/src/main/java/org/geysermc/geyser/entity/type/LivingEntity.java
+++ b/core/src/main/java/org/geysermc/geyser/entity/type/LivingEntity.java
@@ -41,6 +41,7 @@ import org.cloudburstmc.protocol.bedrock.packet.MobEquipmentPacket;
 import org.cloudburstmc.protocol.bedrock.packet.UpdateAttributesPacket;
 import org.geysermc.geyser.entity.EntityDefinition;
 import org.geysermc.geyser.entity.attribute.GeyserAttributeType;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.inventory.GeyserItemStack;
 import org.geysermc.geyser.item.Items;
 import org.geysermc.geyser.registry.type.ItemMapping;
@@ -400,9 +401,25 @@ public class LivingEntity extends Entity {
                     this.maxHealth = Math.max((float) AttributeUtils.calculateValue(javaAttribute), 1f);
                     newAttributes.add(createHealthAttribute());
                 }
+                case GENERIC_MOVEMENT_SPEED -> {
+                    AttributeData attributeData = calculateAttribute(javaAttribute, GeyserAttributeType.MOVEMENT_SPEED);
+                    newAttributes.add(attributeData);
+                    if (this instanceof ClientVehicle clientVehicle) {
+                        clientVehicle.getVehicleComponent().setMoveSpeed(attributeData.getValue());
+                    }
+                }
+                case GENERIC_STEP_HEIGHT -> {
+                    if (this instanceof ClientVehicle clientVehicle) {
+                        clientVehicle.getVehicleComponent().setStepHeight((float) AttributeUtils.calculateValue(javaAttribute));
+                    }
+                }
+                case GENERIC_GRAVITY ->  {
+                    if (this instanceof ClientVehicle clientVehicle) {
+                        clientVehicle.getVehicleComponent().setGravity(AttributeUtils.calculateValue(javaAttribute));
+                    }
+                }
                 case GENERIC_ATTACK_DAMAGE -> newAttributes.add(calculateAttribute(javaAttribute, GeyserAttributeType.ATTACK_DAMAGE));
                 case GENERIC_FLYING_SPEED -> newAttributes.add(calculateAttribute(javaAttribute, GeyserAttributeType.FLYING_SPEED));
-                case GENERIC_MOVEMENT_SPEED -> newAttributes.add(calculateAttribute(javaAttribute, GeyserAttributeType.MOVEMENT_SPEED));
                 case GENERIC_FOLLOW_RANGE -> newAttributes.add(calculateAttribute(javaAttribute, GeyserAttributeType.FOLLOW_RANGE));
                 case GENERIC_KNOCKBACK_RESISTANCE -> newAttributes.add(calculateAttribute(javaAttribute, GeyserAttributeType.KNOCKBACK_RESISTANCE));
                 case GENERIC_JUMP_STRENGTH -> newAttributes.add(calculateAttribute(javaAttribute, GeyserAttributeType.HORSE_JUMP_STRENGTH));
diff --git a/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/PigEntity.java b/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/PigEntity.java
index 446e3e1095c5ad4acdfcf785496b08edee10ad44..d6f0ff95e924f2de1063cd3cd1bbfa775dfb9131 100644
--- a/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/PigEntity.java
+++ b/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/PigEntity.java
@@ -27,20 +27,27 @@ package org.geysermc.geyser.entity.type.living.animal;
 
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import org.cloudburstmc.math.vector.Vector2f;
 import org.cloudburstmc.math.vector.Vector3f;
 import org.cloudburstmc.protocol.bedrock.data.entity.EntityFlag;
 import org.geysermc.geyser.entity.EntityDefinition;
+import org.geysermc.geyser.entity.vehicle.BoostableVehicleComponent;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
+import org.geysermc.geyser.entity.vehicle.VehicleComponent;
 import org.geysermc.geyser.inventory.GeyserItemStack;
+import org.geysermc.geyser.item.Items;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.session.cache.tags.ItemTag;
 import org.geysermc.geyser.util.EntityUtils;
 import org.geysermc.geyser.util.InteractionResult;
 import org.geysermc.geyser.util.InteractiveTag;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.type.IntEntityMetadata;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.player.Hand;
 
 import java.util.UUID;
 
-public class PigEntity extends AnimalEntity {
+public class PigEntity extends AnimalEntity implements ClientVehicle {
+    private final BoostableVehicleComponent<PigEntity> vehicleComponent = new BoostableVehicleComponent<>(this, 1.0f);
 
     public PigEntity(GeyserSession session, int entityId, long geyserId, UUID uuid, EntityDefinition<?> definition, Vector3f position, Vector3f motion, float yaw, float pitch, float headYaw) {
         super(session, entityId, geyserId, uuid, definition, position, motion, yaw, pitch, headYaw);
@@ -84,4 +91,31 @@ public class PigEntity extends AnimalEntity {
             }
         }
     }
+
+    public void setBoost(IntEntityMetadata entityMetadata) {
+        vehicleComponent.startBoost(entityMetadata.getPrimitiveValue());
+    }
+
+    @Override
+    public VehicleComponent<?> getVehicleComponent() {
+        return vehicleComponent;
+    }
+
+    @Override
+    public Vector2f getAdjustedInput(Vector2f input) {
+        return Vector2f.UNIT_Y;
+    }
+
+    @Override
+    public float getVehicleSpeed() {
+        return vehicleComponent.getMoveSpeed() * 0.225f * vehicleComponent.getBoostMultiplier();
+    }
+
+    @Override
+    public boolean isClientControlled() {
+        return getFlag(EntityFlag.SADDLED)
+                && !passengers.isEmpty()
+                && passengers.get(0) == session.getPlayerEntity()
+                && session.getPlayerInventory().isHolding(Items.CARROT_ON_A_STICK);
+    }
 }
diff --git a/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/StriderEntity.java b/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/StriderEntity.java
index 0291f75d9b86a5eca46dbcc939f863e1a0f1e6b7..bee133c53fd06d0b9e7fb8e436b2c44caa33dcf9 100644
--- a/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/StriderEntity.java
+++ b/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/StriderEntity.java
@@ -27,23 +27,30 @@ package org.geysermc.geyser.entity.type.living.animal;
 
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import org.cloudburstmc.math.vector.Vector2f;
 import org.cloudburstmc.math.vector.Vector3f;
 import org.cloudburstmc.protocol.bedrock.data.entity.EntityFlag;
 import org.geysermc.geyser.entity.EntityDefinition;
 import org.geysermc.geyser.entity.type.Entity;
+import org.geysermc.geyser.entity.vehicle.BoostableVehicleComponent;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
+import org.geysermc.geyser.entity.vehicle.VehicleComponent;
 import org.geysermc.geyser.inventory.GeyserItemStack;
+import org.geysermc.geyser.item.Items;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.session.cache.tags.ItemTag;
 import org.geysermc.geyser.util.EntityUtils;
 import org.geysermc.geyser.util.InteractionResult;
 import org.geysermc.geyser.util.InteractiveTag;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.type.BooleanEntityMetadata;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.type.IntEntityMetadata;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.player.Hand;
 
 import java.util.UUID;
 
-public class StriderEntity extends AnimalEntity {
+public class StriderEntity extends AnimalEntity implements ClientVehicle {
 
+    private final BoostableVehicleComponent<StriderEntity> vehicleComponent = new BoostableVehicleComponent<>(this, 1.0f);
     private boolean isCold = false;
 
     public StriderEntity(GeyserSession session, int entityId, long geyserId, UUID uuid, EntityDefinition<?> definition, Vector3f position, Vector3f motion, float yaw, float pitch, float headYaw) {
@@ -131,4 +138,36 @@ public class StriderEntity extends AnimalEntity {
             }
         }
     }
+
+    public void setBoost(IntEntityMetadata entityMetadata) {
+        vehicleComponent.startBoost(entityMetadata.getPrimitiveValue());
+    }
+
+    @Override
+    public VehicleComponent<?> getVehicleComponent() {
+        return vehicleComponent;
+    }
+
+    @Override
+    public Vector2f getAdjustedInput(Vector2f input) {
+        return Vector2f.UNIT_Y;
+    }
+
+    @Override
+    public float getVehicleSpeed() {
+        return vehicleComponent.getMoveSpeed() * (isCold ? 0.35f : 0.55f) * vehicleComponent.getBoostMultiplier();
+    }
+
+    @Override
+    public boolean isClientControlled() {
+        return getFlag(EntityFlag.SADDLED)
+                && !passengers.isEmpty()
+                && passengers.get(0) == session.getPlayerEntity()
+                && session.getPlayerInventory().isHolding(Items.WARPED_FUNGUS_ON_A_STICK);
+    }
+
+    @Override
+    public boolean canWalkOnLava() {
+        return true;
+    }
 }
diff --git a/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/horse/CamelEntity.java b/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/horse/CamelEntity.java
index ee3b2be7020b232ef24d337b12d16c1847c8a67d..3c0bf1a70e059643fa12e8eee233468f35f12e52 100644
--- a/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/horse/CamelEntity.java
+++ b/core/src/main/java/org/geysermc/geyser/entity/type/living/animal/horse/CamelEntity.java
@@ -25,26 +25,36 @@
 
 package org.geysermc.geyser.entity.type.living.animal.horse;
 
+import org.cloudburstmc.math.vector.Vector2f;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.cloudburstmc.math.vector.Vector3f;
+import org.cloudburstmc.protocol.bedrock.data.AttributeData;
 import org.cloudburstmc.protocol.bedrock.data.entity.EntityDataTypes;
 import org.cloudburstmc.protocol.bedrock.data.entity.EntityEventType;
 import org.cloudburstmc.protocol.bedrock.data.entity.EntityFlag;
 import org.cloudburstmc.protocol.bedrock.data.inventory.ContainerType;
 import org.cloudburstmc.protocol.bedrock.packet.EntityEventPacket;
 import org.geysermc.geyser.entity.EntityDefinition;
+import org.geysermc.geyser.entity.attribute.GeyserAttributeType;
+import org.geysermc.geyser.entity.vehicle.CamelVehicleComponent;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
+import org.geysermc.geyser.entity.vehicle.VehicleComponent;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.session.cache.tags.ItemTag;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.attribute.Attribute;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.attribute.AttributeType;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.Pose;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.type.BooleanEntityMetadata;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.type.ByteEntityMetadata;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.type.LongEntityMetadata;
 
 import java.util.UUID;
 
-public class CamelEntity extends AbstractHorseEntity {
-
+public class CamelEntity extends AbstractHorseEntity implements ClientVehicle {
     public static final float SITTING_HEIGHT_DIFFERENCE = 1.43F;
 
+    private final CamelVehicleComponent vehicleComponent = new CamelVehicleComponent(this);
+
     public CamelEntity(GeyserSession session, int entityId, long geyserId, UUID uuid, EntityDefinition<?> definition, Vector3f position, Vector3f motion, float yaw, float pitch, float headYaw) {
         super(session, entityId, geyserId, uuid, definition, position, motion, yaw, pitch, headYaw);
 
@@ -111,5 +121,58 @@ public class CamelEntity extends AbstractHorseEntity {
     }
 
     public void setDashing(BooleanEntityMetadata entityMetadata) {
+        // Java sends true to show dash animation and start the dash cooldown,
+        // false ends the dash animation, not the cooldown.
+        // Bedrock shows dash animation if HAS_DASH_COOLDOWN is set and the camel is above ground
+        if (entityMetadata.getPrimitiveValue()) {
+            setFlag(EntityFlag.HAS_DASH_COOLDOWN, true);
+            vehicleComponent.startDashCooldown();
+        } else if (!isClientControlled()) { // Don't remove dash cooldown prematurely if client is controlling
+            setFlag(EntityFlag.HAS_DASH_COOLDOWN, false);
+        }
+    }
+
+    public void setLastPoseTick(LongEntityMetadata entityMetadata) {
+        // Tick is based on world time. If negative, the camel is sitting.
+        // Must be compared to world time to know if the camel is fully standing/sitting or transitioning.
+        vehicleComponent.setLastPoseTick(entityMetadata.getPrimitiveValue());
+    }
+
+    @Override
+    protected AttributeData calculateAttribute(Attribute javaAttribute, GeyserAttributeType type) {
+        AttributeData attributeData = super.calculateAttribute(javaAttribute, type);
+        if (javaAttribute.getType() == AttributeType.Builtin.GENERIC_JUMP_STRENGTH) {
+            vehicleComponent.setHorseJumpStrength(attributeData.getValue());
+        }
+        return attributeData;
+    }
+
+    @Override
+    public VehicleComponent<?> getVehicleComponent() {
+        return vehicleComponent;
+    }
+
+    @Override
+    public Vector2f getAdjustedInput(Vector2f input) {
+        return input.mul(0.5f, input.getY() < 0 ? 0.25f : 1.0f);
+    }
+
+    @Override
+    public boolean isClientControlled() {
+        return getFlag(EntityFlag.SADDLED) && !passengers.isEmpty() && passengers.get(0) == session.getPlayerEntity();
+    }
+
+    @Override
+    public float getVehicleSpeed() {
+        float moveSpeed = vehicleComponent.getMoveSpeed();
+        if (!getFlag(EntityFlag.HAS_DASH_COOLDOWN) && session.getPlayerEntity().getFlag(EntityFlag.SPRINTING)) {
+            return moveSpeed + 0.1f;
+        }
+        return moveSpeed;
+    }
+
+    @Override
+    public boolean canClimb() {
+        return false;
     }
 }
diff --git a/core/src/main/java/org/geysermc/geyser/entity/type/player/SessionPlayerEntity.java b/core/src/main/java/org/geysermc/geyser/entity/type/player/SessionPlayerEntity.java
index ad6729c427c63b3189b5599702590a52d64a4f03..d220441e519a096dfb8d27f7aae23dbd97cf1b31 100644
--- a/core/src/main/java/org/geysermc/geyser/entity/type/player/SessionPlayerEntity.java
+++ b/core/src/main/java/org/geysermc/geyser/entity/type/player/SessionPlayerEntity.java
@@ -28,6 +28,7 @@ package org.geysermc.geyser.entity.type.player;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import lombok.Getter;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import org.cloudburstmc.math.vector.Vector2f;
 import org.cloudburstmc.math.vector.Vector3f;
 import org.cloudburstmc.protocol.bedrock.data.AttributeData;
 import org.cloudburstmc.protocol.bedrock.data.entity.EntityDataTypes;
@@ -39,6 +40,7 @@ import org.geysermc.geyser.network.GameProtocol;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.util.AttributeUtils;
 import org.geysermc.geyser.util.DimensionUtils;
+import org.geysermc.geyser.util.MathUtils;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.attribute.Attribute;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.attribute.AttributeType;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.metadata.GlobalPos;
@@ -66,6 +68,16 @@ public class SessionPlayerEntity extends PlayerEntity {
      */
     @Getter
     private boolean isRidingInFront;
+    /**
+     * Used when emulating client-side vehicles
+     */
+    @Getter
+    private Vector2f vehicleInput = Vector2f.ZERO;
+    /**
+     * Used when emulating client-side vehicles
+     */
+    @Getter
+    private int vehicleJumpStrength;
 
     private int lastAirSupply = getMaxAir();
 
@@ -276,4 +288,15 @@ public class SessionPlayerEntity extends PlayerEntity {
     public void resetAir() {
         this.setAirSupply(getMaxAir());
     }
+
+    public void setVehicleInput(Vector2f vehicleInput) {
+        this.vehicleInput = Vector2f.from(
+                MathUtils.clamp(vehicleInput.getX(), -1.0f, 1.0f),
+                MathUtils.clamp(vehicleInput.getY(), -1.0f, 1.0f)
+        );
+    }
+
+    public void setVehicleJumpStrength(int vehicleJumpStrength) {
+        this.vehicleJumpStrength = MathUtils.constrain(vehicleJumpStrength, 0, 100);
+    }
 }
diff --git a/core/src/main/java/org/geysermc/geyser/entity/vehicle/BoostableVehicleComponent.java b/core/src/main/java/org/geysermc/geyser/entity/vehicle/BoostableVehicleComponent.java
new file mode 100644
index 0000000000000000000000000000000000000000..febe78ab4488bd78c0660c4259be47b24fef0dcf
--- /dev/null
+++ b/core/src/main/java/org/geysermc/geyser/entity/vehicle/BoostableVehicleComponent.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2019-2023 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package org.geysermc.geyser.entity.vehicle;
+
+import org.cloudburstmc.math.TrigMath;
+import org.geysermc.geyser.entity.type.LivingEntity;
+
+public class BoostableVehicleComponent<T extends LivingEntity & ClientVehicle> extends VehicleComponent<T> {
+    private int boostLength;
+    private int boostTicks = 1;
+
+    public BoostableVehicleComponent(T vehicle, float stepHeight) {
+        super(vehicle, stepHeight);
+    }
+
+    public void startBoost(int boostLength) {
+        this.boostLength = boostLength;
+        this.boostTicks = 1;
+    }
+
+    public float getBoostMultiplier() {
+        if (isBoosting()) {
+            return 1.0f + 1.15f * TrigMath.sin((float) boostTicks / (float) boostLength * TrigMath.PI);
+        }
+        return 1.0f;
+    }
+
+    public boolean isBoosting() {
+        return boostTicks <= boostLength;
+    }
+
+    @Override
+    public boolean tickVehicle() {
+        boolean clientControlled = super.tickVehicle();
+        if (clientControlled && isBoosting()) {
+            // TODO: the client ticks boost if any player is controlling
+            boostTicks++;
+        }
+
+        return clientControlled;
+    }
+}
diff --git a/core/src/main/java/org/geysermc/geyser/entity/vehicle/CamelVehicleComponent.java b/core/src/main/java/org/geysermc/geyser/entity/vehicle/CamelVehicleComponent.java
new file mode 100644
index 0000000000000000000000000000000000000000..55dc7b0be017f77b9861637c8c92d77ea92fbab9
--- /dev/null
+++ b/core/src/main/java/org/geysermc/geyser/entity/vehicle/CamelVehicleComponent.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2019-2023 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package org.geysermc.geyser.entity.vehicle;
+
+import lombok.Setter;
+import org.cloudburstmc.math.vector.Vector2f;
+import org.cloudburstmc.math.vector.Vector3f;
+import org.cloudburstmc.protocol.bedrock.data.entity.EntityFlag;
+import org.geysermc.geyser.entity.type.living.animal.horse.CamelEntity;
+import org.geysermc.geyser.entity.type.player.SessionPlayerEntity;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.Effect;
+
+public class CamelVehicleComponent extends VehicleComponent<CamelEntity> {
+    private static final int STANDING_TICKS = 52;
+    private static final int DASH_TICKS = 55;
+
+    @Setter
+    private float horseJumpStrength = 0.42f; // Not sent by vanilla Java server when spawned
+
+    @Setter
+    private long lastPoseTick;
+
+    private int dashTick;
+    private int effectJumpBoost;
+
+    public CamelVehicleComponent(CamelEntity vehicle) {
+        super(vehicle, 1.5f);
+    }
+
+    public void startDashCooldown() {
+        this.dashTick = vehicle.getSession().getTicks() + DASH_TICKS;
+    }
+
+    @Override
+    public boolean tickVehicle() {
+        if (this.dashTick != 0) {
+            if (vehicle.getSession().getTicks() > this.dashTick) {
+                vehicle.setFlag(EntityFlag.HAS_DASH_COOLDOWN, false);
+                this.dashTick = 0;
+            } else {
+                vehicle.setFlag(EntityFlag.HAS_DASH_COOLDOWN, true);
+            }
+        }
+
+        vehicle.setFlag(EntityFlag.CAN_DASH, vehicle.getFlag(EntityFlag.SADDLED) && !isStationary());
+        vehicle.updateBedrockMetadata();
+
+        return super.tickVehicle();
+    }
+
+    @Override
+    public void onDismount() {
+        vehicle.setFlag(EntityFlag.HAS_DASH_COOLDOWN, false);
+        vehicle.updateBedrockMetadata();
+        super.onDismount();
+    }
+
+    @Override
+    protected boolean travel(VehicleContext ctx, float speed) {
+        if (vehicle.isOnGround() && isStationary()) {
+            vehicle.setMotion(vehicle.getMotion().mul(0, 1, 0));
+        }
+
+        return super.travel(ctx, speed);
+    }
+
+    @Override
+    protected Vector3f getInputVelocity(VehicleContext ctx, float speed) {
+        if (isStationary()) {
+            return Vector3f.ZERO;
+        }
+
+        SessionPlayerEntity player = vehicle.getSession().getPlayerEntity();
+        Vector3f inputVelocity = super.getInputVelocity(ctx, speed);
+        float jumpStrength = player.getVehicleJumpStrength();
+
+        if (jumpStrength > 0) {
+            player.setVehicleJumpStrength(0);
+
+            if (jumpStrength >= 90) {
+                jumpStrength = 1.0f;
+            } else {
+                jumpStrength = 0.4f + 0.4f * jumpStrength / 90.0f;
+            }
+
+            return inputVelocity.add(Vector3f.createDirectionDeg(0, -player.getYaw())
+                    .mul(22.2222f * jumpStrength * this.moveSpeed * getVelocityMultiplier(ctx))
+                    .up(1.4285f * jumpStrength * (this.horseJumpStrength * getJumpVelocityMultiplier(ctx) + (this.effectJumpBoost * 0.1f))));
+        }
+
+        return inputVelocity;
+    }
+
+    @Override
+    protected Vector2f getVehicleRotation() {
+        if (isStationary()) {
+            return Vector2f.from(vehicle.getYaw(), vehicle.getPitch());
+        }
+        return super.getVehicleRotation();
+    }
+
+    /**
+     * Checks if the camel is sitting
+     * or transitioning to standing pose.
+     */
+    private boolean isStationary() {
+        // Java checks if sitting using lastPoseTick
+        return this.lastPoseTick < 0 || vehicle.getSession().getWorldTicks() < this.lastPoseTick + STANDING_TICKS;
+    }
+
+    @Override
+    public void setEffect(Effect effect, int effectAmplifier) {
+        if (effect == Effect.JUMP_BOOST) {
+            effectJumpBoost = effectAmplifier + 1;
+        } else {
+            super.setEffect(effect, effectAmplifier);
+        }
+    }
+
+    @Override
+    public void removeEffect(Effect effect) {
+        if (effect == Effect.JUMP_BOOST) {
+            effectJumpBoost = 0;
+        } else {
+            super.removeEffect(effect);
+        }
+    }
+}
diff --git a/core/src/main/java/org/geysermc/geyser/entity/vehicle/ClientVehicle.java b/core/src/main/java/org/geysermc/geyser/entity/vehicle/ClientVehicle.java
new file mode 100644
index 0000000000000000000000000000000000000000..e6aaf1daac019426972c4f049080b54008935c08
--- /dev/null
+++ b/core/src/main/java/org/geysermc/geyser/entity/vehicle/ClientVehicle.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2019-2023 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package org.geysermc.geyser.entity.vehicle;
+
+import org.cloudburstmc.math.vector.Vector2f;
+
+public interface ClientVehicle {
+    VehicleComponent<?> getVehicleComponent();
+
+    Vector2f getAdjustedInput(Vector2f input);
+
+    float getVehicleSpeed();
+
+    boolean isClientControlled();
+
+    default boolean canWalkOnLava() {
+        return false;
+    }
+
+    default boolean canClimb() {
+        return true;
+    }
+}
diff --git a/core/src/main/java/org/geysermc/geyser/entity/vehicle/VehicleComponent.java b/core/src/main/java/org/geysermc/geyser/entity/vehicle/VehicleComponent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b49301faa9f15cf1f645041b20a32eebdbcbbad5
--- /dev/null
+++ b/core/src/main/java/org/geysermc/geyser/entity/vehicle/VehicleComponent.java
@@ -0,0 +1,863 @@
+/*
+ * Copyright (c) 2019-2023 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package org.geysermc.geyser.entity.vehicle;
+
+import it.unimi.dsi.fastutil.objects.ObjectDoublePair;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.cloudburstmc.math.TrigMath;
+import org.cloudburstmc.math.vector.Vector2f;
+import org.cloudburstmc.math.vector.Vector3d;
+import org.cloudburstmc.math.vector.Vector3f;
+import org.cloudburstmc.math.vector.Vector3i;
+import org.cloudburstmc.protocol.bedrock.data.entity.EntityFlag;
+import org.cloudburstmc.protocol.bedrock.packet.MoveEntityDeltaPacket;
+import org.geysermc.erosion.util.BlockPositionIterator;
+import org.geysermc.geyser.entity.attribute.GeyserAttributeType;
+import org.geysermc.geyser.entity.type.LivingEntity;
+import org.geysermc.geyser.level.block.BlockStateValues;
+import org.geysermc.geyser.level.block.Blocks;
+import org.geysermc.geyser.level.block.Fluid;
+import org.geysermc.geyser.level.block.property.Properties;
+import org.geysermc.geyser.level.block.type.BedBlock;
+import org.geysermc.geyser.level.block.type.Block;
+import org.geysermc.geyser.level.block.type.BlockState;
+import org.geysermc.geyser.level.block.type.TrapDoorBlock;
+import org.geysermc.geyser.level.physics.BoundingBox;
+import org.geysermc.geyser.level.physics.CollisionManager;
+import org.geysermc.geyser.level.physics.Direction;
+import org.geysermc.geyser.session.cache.tags.BlockTag;
+import org.geysermc.geyser.translator.collision.BlockCollision;
+import org.geysermc.geyser.translator.collision.SolidCollision;
+import org.geysermc.geyser.util.BlockUtils;
+import org.geysermc.geyser.util.MathUtils;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.Effect;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.attribute.AttributeType;
+import org.geysermc.mcprotocollib.protocol.data.game.entity.type.EntityType;
+import org.geysermc.mcprotocollib.protocol.packet.ingame.serverbound.level.ServerboundMoveVehiclePacket;
+
+public class VehicleComponent<T extends LivingEntity & ClientVehicle> {
+    private static final ObjectDoublePair<Fluid> EMPTY_FLUID_PAIR = ObjectDoublePair.of(Fluid.EMPTY, 0.0);
+    private static final float MAX_LOGICAL_FLUID_HEIGHT = 8.0f / BlockStateValues.NUM_FLUID_LEVELS;
+    private static final float BASE_SLIPPERINESS_CUBED = 0.6f * 0.6f * 0.6f;
+    private static final float MIN_VELOCITY = 0.003f;
+    private static final float CLIMB_SPEED = 0.15f;
+
+    protected final T vehicle;
+    protected final BoundingBox boundingBox;
+
+    protected float stepHeight;
+    protected float moveSpeed;
+    protected double gravity;
+    protected int effectLevitation;
+    protected boolean effectSlowFalling;
+    protected boolean effectWeaving;
+
+    public VehicleComponent(T vehicle, float stepHeight) {
+        this.vehicle = vehicle;
+        this.stepHeight = stepHeight;
+        this.moveSpeed = (float) AttributeType.Builtin.GENERIC_MOVEMENT_SPEED.getDef();
+        this.gravity = AttributeType.Builtin.GENERIC_GRAVITY.getDef();
+
+        double width = Double.parseDouble(Float.toString(vehicle.getBoundingBoxWidth()));
+        double height = Double.parseDouble(Float.toString(vehicle.getBoundingBoxHeight()));
+        this.boundingBox = new BoundingBox(
+                vehicle.getPosition().getX(),
+                vehicle.getPosition().getY() + height / 2,
+                vehicle.getPosition().getZ(),
+                width, height, width
+        );
+    }
+
+    public void setWidth(float width) {
+        double doubleWidth = Double.parseDouble(Float.toString(width));
+        boundingBox.setSizeX(doubleWidth);
+        boundingBox.setSizeZ(doubleWidth);
+    }
+
+    public void setHeight(float height) {
+        double doubleHeight = Double.parseDouble(Float.toString(height));
+        boundingBox.translate(0, (doubleHeight - boundingBox.getSizeY()) / 2, 0);
+        boundingBox.setSizeY(doubleHeight);
+    }
+
+    public void moveAbsolute(double x, double y, double z) {
+        boundingBox.setMiddleX(x);
+        boundingBox.setMiddleY(y + boundingBox.getSizeY() / 2);
+        boundingBox.setMiddleZ(z);
+    }
+
+    public void moveRelative(double x, double y, double z) {
+        boundingBox.translate(x, y, z);
+    }
+
+    public void setEffect(Effect effect, int effectAmplifier) {
+        switch (effect) {
+            case LEVITATION -> effectLevitation = effectAmplifier + 1;
+            case SLOW_FALLING -> effectSlowFalling = true;
+            case WEAVING -> effectWeaving = true;
+        }
+    }
+
+    public void removeEffect(Effect effect) {
+        switch (effect) {
+            case LEVITATION -> effectLevitation = 0;
+            case SLOW_FALLING -> effectSlowFalling = false;
+            case WEAVING -> effectWeaving = false;
+        }
+    }
+
+    public void setMoveSpeed(float moveSpeed) {
+        this.moveSpeed = moveSpeed;
+    }
+
+    public float getMoveSpeed() {
+        return moveSpeed;
+    }
+
+    public void setStepHeight(float stepHeight) {
+        this.stepHeight = MathUtils.clamp(stepHeight, 1.0f, 10.0f);
+    }
+
+    public void setGravity(double gravity) {
+        this.gravity = MathUtils.constrain(gravity, -1.0, 1.0);
+    }
+
+    public void onMount() {
+        vehicle.getSession().getPlayerEntity().setVehicleInput(Vector2f.ZERO);
+        vehicle.getSession().getPlayerEntity().setVehicleJumpStrength(0);
+    }
+
+    public void onDismount() {
+        //
+    }
+
+    public boolean tickVehicle() {
+        if (!vehicle.isClientControlled()) {
+            return false;
+        }
+
+        VehicleContext ctx = new VehicleContext();
+        ctx.loadSurroundingBlocks();
+
+        ObjectDoublePair<Fluid> fluidHeight = updateFluidMovement(ctx);
+        switch (fluidHeight.left()) {
+            case WATER -> waterMovement(ctx);
+            case LAVA -> {
+                if (vehicle.canWalkOnLava() && ctx.centerBlock().is(Blocks.LAVA)) {
+                    landMovement(ctx);
+                } else {
+                    lavaMovement(ctx, fluidHeight.rightDouble());
+                }
+            }
+            case EMPTY -> landMovement(ctx);
+        }
+
+        return true;
+    }
+
+    protected ObjectDoublePair<Fluid> updateFluidMovement(VehicleContext ctx) {
+        BoundingBox box = boundingBox.clone();
+        box.expand(-0.001);
+
+        Vector3d min = box.getMin();
+        Vector3d max = box.getMax();
+
+        BlockPositionIterator iter = BlockPositionIterator.fromMinMax(min.getFloorX(), min.getFloorY(), min.getFloorZ(), max.getFloorX(), max.getFloorY(), max.getFloorZ());
+
+        double waterHeight = getFluidHeightAndApplyMovement(ctx, iter, Fluid.WATER, 0.014, min.getY());
+        double lavaHeight = getFluidHeightAndApplyMovement(ctx, iter, Fluid.LAVA, vehicle.getSession().getDimensionType().ultrawarm() ? 0.007 : 0.007 / 3, min.getY());
+
+        if (lavaHeight > 0 && vehicle.getDefinition().entityType() == EntityType.STRIDER) {
+            Vector3i blockPos = ctx.centerPos().toInt();
+            if (!CollisionManager.FLUID_COLLISION.isBelow(blockPos.getY(), boundingBox)
+                    || ctx.getBlock(blockPos.up()).is(Blocks.LAVA)) {
+                vehicle.setMotion(vehicle.getMotion().mul(0.5f).add(0, 0.05f, 0));
+            } else {
+                vehicle.setOnGround(true);
+            }
+        }
+
+        // Water movement has priority over lava movement
+        if (waterHeight > 0) {
+            return ObjectDoublePair.of(Fluid.WATER, waterHeight);
+        }
+
+        if (lavaHeight > 0) {
+            return ObjectDoublePair.of(Fluid.LAVA, lavaHeight);
+        }
+
+        return EMPTY_FLUID_PAIR;
+    }
+
+    protected double getFluidHeightAndApplyMovement(VehicleContext ctx, BlockPositionIterator iter, Fluid fluid, double speed, double minY) {
+        Vector3d totalVelocity = Vector3d.ZERO;
+        double maxFluidHeight = 0;
+        int fluidBlocks = 0;
+
+        for (iter.reset(); iter.hasNext(); iter.next()) {
+            int blockId = ctx.getBlockId(iter);
+            if (BlockStateValues.getFluid(blockId) != fluid) {
+                continue;
+            }
+
+            Vector3i blockPos = Vector3i.from(iter.getX(), iter.getY(), iter.getZ());
+            float worldFluidHeight = getWorldFluidHeight(fluid, blockId);
+
+            double vehicleFluidHeight = blockPos.getY() + worldFluidHeight - minY;
+            if (vehicleFluidHeight < 0) {
+                continue;
+            }
+
+            boolean flowBlocked = worldFluidHeight != 1; // This is only used for determining if a falling fluid should drag the vehicle downwards
+            Vector3d velocity = Vector3d.ZERO;
+            for (Direction direction : Direction.HORIZONTAL) {
+                Vector3i adjacentBlockPos = blockPos.add(direction.getUnitVector());
+                int adjacentBlockId = ctx.getBlockId(adjacentBlockPos);
+                Fluid adjacentFluid = BlockStateValues.getFluid(adjacentBlockId);
+
+                float fluidHeightDiff = 0;
+                if (adjacentFluid == fluid) {
+                    fluidHeightDiff = getLogicalFluidHeight(fluid, blockId) - getLogicalFluidHeight(fluid, adjacentBlockId);
+                } else if (adjacentFluid == Fluid.EMPTY) {
+                    // If the adjacent block is not a fluid and does not have collision,
+                    // check if there is a fluid under it
+                    BlockCollision adjacentBlockCollision = BlockUtils.getCollision(adjacentBlockId);
+                    if (adjacentBlockCollision == null) {
+                        float adjacentFluidHeight = getLogicalFluidHeight(fluid, ctx.getBlockId(adjacentBlockPos.add(Direction.DOWN.getUnitVector())));
+                        if (adjacentFluidHeight != -1) { // Only care about same type of fluid
+                            fluidHeightDiff = getLogicalFluidHeight(fluid, blockId) - (adjacentFluidHeight - MAX_LOGICAL_FLUID_HEIGHT);
+                        }
+                    } else if (!flowBlocked) {
+                        flowBlocked = isFlowBlocked(fluid, adjacentBlockId);
+                    }
+                }
+
+                if (fluidHeightDiff != 0) {
+                    velocity = velocity.add(direction.getUnitVector().toDouble().mul(fluidHeightDiff));
+                }
+            }
+
+            if (worldFluidHeight == 1) { // If falling fluid
+                // If flow is not blocked, check if it is blocked for the fluid above
+                if (!flowBlocked) {
+                    Vector3i blockPosUp = blockPos.up();
+                    for (Direction direction : Direction.HORIZONTAL) {
+                        flowBlocked = isFlowBlocked(fluid, ctx.getBlockId(blockPosUp.add(direction.getUnitVector())));
+                        if (flowBlocked) {
+                            break;
+                        }
+                    }
+                }
+
+                if (flowBlocked) {
+                    velocity = javaNormalize(velocity).add(0.0, -6.0, 0.0);
+                }
+            }
+
+            velocity = javaNormalize(velocity);
+
+            maxFluidHeight = Math.max(vehicleFluidHeight, maxFluidHeight);
+            if (maxFluidHeight < 0.4) {
+                velocity = velocity.mul(maxFluidHeight);
+            }
+
+            totalVelocity = totalVelocity.add(velocity);
+            fluidBlocks++;
+        }
+
+        if (!totalVelocity.equals(Vector3d.ZERO)) {
+            Vector3f motion = vehicle.getMotion();
+
+            totalVelocity = javaNormalize(totalVelocity.mul(1.0 / fluidBlocks));
+            totalVelocity = totalVelocity.mul(speed);
+
+            if (totalVelocity.length() < 0.0045 && Math.abs(motion.getX()) < MIN_VELOCITY && Math.abs(motion.getZ()) < MIN_VELOCITY) {
+                totalVelocity = javaNormalize(totalVelocity).mul(0.0045);
+            }
+
+            vehicle.setMotion(motion.add(totalVelocity.toFloat()));
+        }
+
+        return maxFluidHeight;
+    }
+
+    /**
+     * Java edition returns the zero vector if the length of the input vector is less than 0.0001
+     */
+    protected Vector3d javaNormalize(Vector3d vec) {
+        double len = vec.length();
+        return len < 1.0E-4 ? Vector3d.ZERO : Vector3d.from(vec.getX() / len, vec.getY() / len, vec.getZ() / len);
+    }
+
+    protected float getWorldFluidHeight(Fluid fluidType, int blockId) {
+        return (float) switch (fluidType) {
+            case WATER -> BlockStateValues.getWaterHeight(blockId);
+            case LAVA -> BlockStateValues.getLavaHeight(blockId);
+            case EMPTY -> -1;
+        };
+    }
+
+    protected float getLogicalFluidHeight(Fluid fluidType, int blockId) {
+        return Math.min(getWorldFluidHeight(fluidType, blockId), MAX_LOGICAL_FLUID_HEIGHT);
+    }
+
+    protected boolean isFlowBlocked(Fluid fluid, int adjacentBlockId) {
+        if (BlockState.of(adjacentBlockId).is(Blocks.ICE)) {
+            return false;
+        }
+
+        if (BlockStateValues.getFluid(adjacentBlockId) == fluid) {
+            return false;
+        }
+
+        // TODO: supposed to check if the opposite face of the block touching the fluid is solid, instead of SolidCollision
+        return BlockUtils.getCollision(adjacentBlockId) instanceof SolidCollision;
+    }
+
+    protected void waterMovement(VehicleContext ctx) {
+        double gravity = getGravity();
+        float drag = vehicle.getFlag(EntityFlag.SPRINTING) ? 0.9f : 0.8f; // 0.8f: getBaseMovementSpeedMultiplier
+        double originalY = ctx.centerPos().getY();
+        boolean falling = vehicle.getMotion().getY() <= 0;
+
+        // NOT IMPLEMENTED: depth strider and dolphins grace
+
+        boolean horizontalCollision = travel(ctx, 0.02f);
+
+        if (horizontalCollision && isClimbing(ctx)) {
+            vehicle.setMotion(Vector3f.from(vehicle.getMotion().getX(), 0.2f, vehicle.getMotion().getZ()));
+        }
+
+        vehicle.setMotion(vehicle.getMotion().mul(drag, 0.8f, drag));
+        vehicle.setMotion(getFluidGravity(gravity, falling));
+
+        if (horizontalCollision && shouldApplyFluidJumpBoost(ctx, originalY)) {
+            vehicle.setMotion(Vector3f.from(vehicle.getMotion().getX(), 0.3f, vehicle.getMotion().getZ()));
+        }
+    }
+
+    protected void lavaMovement(VehicleContext ctx, double lavaHeight) {
+        double gravity = getGravity();
+        double originalY = ctx.centerPos().getY();
+        boolean falling = vehicle.getMotion().getY() <= 0;
+
+        boolean horizontalCollision = travel(ctx, 0.02f);
+
+        if (lavaHeight <= (boundingBox.getSizeY() * 0.85 < 0.4 ? 0.0 : 0.4)) { // Swim height
+            vehicle.setMotion(vehicle.getMotion().mul(0.5f, 0.8f, 0.5f));
+            vehicle.setMotion(getFluidGravity(gravity, falling));
+        } else {
+            vehicle.setMotion(vehicle.getMotion().mul(0.5f));
+        }
+
+        vehicle.setMotion(vehicle.getMotion().down((float) (gravity / 4.0)));
+
+        if (horizontalCollision && shouldApplyFluidJumpBoost(ctx, originalY)) {
+            vehicle.setMotion(Vector3f.from(vehicle.getMotion().getX(), 0.3f, vehicle.getMotion().getZ()));
+        }
+    }
+
+    protected void landMovement(VehicleContext ctx) {
+        double gravity = getGravity();
+        float slipperiness = BlockStateValues.getSlipperiness(ctx.velocityAffectingBlock());
+        float drag = vehicle.isOnGround() ? 0.91f * slipperiness : 0.91f;
+        float speed = vehicle.getVehicleSpeed() * (vehicle.isOnGround() ? BASE_SLIPPERINESS_CUBED / (slipperiness * slipperiness * slipperiness) : 0.1f);
+
+        boolean horizontalCollision = travel(ctx, speed);
+
+        if (isClimbing(ctx)) {
+            vehicle.setMotion(getClimbingSpeed(horizontalCollision));
+            // NOT IMPLEMENTED: climbing in powdered snow
+        }
+
+        if (effectLevitation > 0) {
+            vehicle.setMotion(vehicle.getMotion().up((0.05f * effectLevitation - vehicle.getMotion().getY()) * 0.2f));
+        } else {
+            vehicle.setMotion(vehicle.getMotion().down((float) gravity));
+            // NOT IMPLEMENTED: slow fall when in unloaded chunk
+        }
+
+        vehicle.setMotion(vehicle.getMotion().mul(drag, 0.98f, drag));
+    }
+
+    protected boolean shouldApplyFluidJumpBoost(VehicleContext ctx, double originalY) {
+        BoundingBox box = boundingBox.clone();
+        box.translate(vehicle.getMotion().toDouble().up(0.6f - ctx.centerPos().getY() + originalY));
+        box.expand(-1.0E-7);
+
+        BlockPositionIterator iter = vehicle.getSession().getCollisionManager().collidableBlocksIterator(box);
+        for (iter.reset(); iter.hasNext(); iter.next()) {
+            int blockId = ctx.getBlockId(iter);
+
+            // Also check for fluids
+            BlockCollision blockCollision = BlockUtils.getCollision(blockId);
+            if (blockCollision == null && BlockStateValues.getFluid(blockId) != Fluid.EMPTY) {
+                blockCollision = CollisionManager.SOLID_COLLISION;
+            }
+
+            if (blockCollision != null && blockCollision.checkIntersection(iter.getX(), iter.getY(), iter.getZ(), box)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    protected Vector3f getClimbingSpeed(boolean horizontalCollision) {
+        Vector3f motion = vehicle.getMotion();
+        return Vector3f.from(
+                MathUtils.clamp(motion.getX(), -CLIMB_SPEED, CLIMB_SPEED),
+                horizontalCollision ? 0.2f : Math.max(motion.getY(), -CLIMB_SPEED),
+                MathUtils.clamp(motion.getZ(), -CLIMB_SPEED, CLIMB_SPEED)
+        );
+    }
+
+    protected Vector3f getFluidGravity(double gravity, boolean falling) {
+        Vector3f motion = vehicle.getMotion();
+        if (gravity != 0 && !vehicle.getFlag(EntityFlag.SPRINTING)) {
+            float newY = (float) (motion.getY() - gravity / 16);
+            if (falling && Math.abs(motion.getY() - 0.005f) >= MIN_VELOCITY && Math.abs(newY) < MIN_VELOCITY) {
+                newY = -MIN_VELOCITY;
+            }
+            return Vector3f.from(motion.getX(), newY, motion.getZ());
+        }
+        return motion;
+    }
+
+    protected @Nullable Vector3f getBlockMovementMultiplier(VehicleContext ctx) {
+        BoundingBox box = boundingBox.clone();
+        box.expand(-1.0E-7);
+
+        Vector3i min = box.getMin().toInt();
+        Vector3i max = box.getMax().toInt();
+
+        // Iterate xyz backwards
+        for (int x = max.getX(); x >= min.getX(); x--) {
+            for (int y = max.getY(); y >= min.getY(); y--) {
+                for (int z = max.getZ(); z >= min.getZ(); z--) {
+                    Block block = ctx.getBlock(x, y, z).block();
+                    Vector3f multiplier = null;
+
+                    if (block == Blocks.COBWEB) {
+                        if (effectWeaving) {
+                            multiplier = Vector3f.from(0.5, 0.25, 0.5);
+                        } else {
+                            multiplier = Vector3f.from(0.25, 0.05f, 0.25);
+                        }
+                    } else if (block == Blocks.POWDER_SNOW) {
+                        multiplier = Vector3f.from(0.9f, 1.5, 0.9f);
+                    } else if (block == Blocks.SWEET_BERRY_BUSH) {
+                        multiplier = Vector3f.from(0.8f, 0.75, 0.8f);
+                    }
+
+                    if (multiplier != null) {
+                        return multiplier;
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    protected void applyBlockCollisionEffects(VehicleContext ctx) {
+        BoundingBox box = boundingBox.clone();
+        box.expand(-1.0E-7);
+
+        Vector3i min = box.getMin().toInt();
+        Vector3i max = box.getMax().toInt();
+
+        BlockPositionIterator iter = BlockPositionIterator.fromMinMax(min.getX(), min.getY(), min.getZ(), max.getX(), max.getY(), max.getZ());
+        for (iter.reset(); iter.hasNext(); iter.next()) {
+            BlockState blockState = ctx.getBlock(iter);
+
+            if (blockState.is(Blocks.HONEY_BLOCK)) {
+                onHoneyBlockCollision();
+            } else if (blockState.is(Blocks.BUBBLE_COLUMN)) {
+                onBubbleColumnCollision(blockState.getValue(Properties.DRAG));
+            }
+        }
+    }
+
+    protected void onHoneyBlockCollision() {
+        if (vehicle.isOnGround() || vehicle.getMotion().getY() >= -0.08f) {
+            return;
+        }
+
+        // NOT IMPLEMENTED: don't slide if inside the honey block
+        Vector3f motion = vehicle.getMotion();
+        float mul = motion.getY() < -0.13f ? -0.05f / motion.getY() : 1;
+        vehicle.setMotion(Vector3f.from(motion.getX() * mul, -0.05f, motion.getZ() * mul));
+    }
+
+    protected void onBubbleColumnCollision(boolean drag) {
+        Vector3f motion = vehicle.getMotion();
+        vehicle.setMotion(Vector3f.from(
+                motion.getX(),
+                drag ? Math.max(-0.3f, motion.getY() - 0.03f) : Math.min(0.7f, motion.getY() + 0.06f),
+                motion.getZ()
+        ));
+    }
+
+    /**
+     * @return True if there was a horizontal collision
+     */
+    protected boolean travel(VehicleContext ctx, float speed) {
+        Vector3f motion = vehicle.getMotion();
+
+        // Java only does this client side
+        motion = motion.mul(0.98f);
+
+        motion = Vector3f.from(
+                Math.abs(motion.getX()) < MIN_VELOCITY ? 0 : motion.getX(),
+                Math.abs(motion.getY()) < MIN_VELOCITY ? 0 : motion.getY(),
+                Math.abs(motion.getZ()) < MIN_VELOCITY ? 0 : motion.getZ()
+        );
+
+        // TODO: isImmobile? set input to 0 and jump to false
+
+        motion = motion.add(getInputVelocity(ctx, speed));
+
+        Vector3f movementMultiplier = getBlockMovementMultiplier(ctx);
+        if (movementMultiplier != null) {
+            motion = motion.mul(movementMultiplier);
+        }
+
+        Vector3d correctedMovement = vehicle.getSession().getCollisionManager().correctMovement(
+                motion.toDouble(), boundingBox, vehicle.isOnGround(), this.stepHeight, true, vehicle.canWalkOnLava()
+        );
+
+        boundingBox.translate(correctedMovement);
+        ctx.loadSurroundingBlocks();
+
+        // Non-zero values indicate a collision on that axis
+        Vector3d moveDiff = motion.toDouble().sub(correctedMovement);
+
+        boolean onGround = moveDiff.getY() != 0 && motion.getY() < 0;
+        boolean horizontalCollision = moveDiff.getX() != 0 || moveDiff.getZ() != 0;
+
+        boolean bounced = false;
+        if (onGround) {
+            Vector3i landingPos = ctx.centerPos().sub(0, 0.2f, 0).toInt();
+            Block landingBlock = ctx.getBlock(landingPos).block();
+
+            if (landingBlock == Blocks.SLIME_BLOCK) {
+                motion = Vector3f.from(motion.getX(), -motion.getY(), motion.getZ());
+                bounced = true;
+
+                // Slow horizontal movement
+                float absY = Math.abs(motion.getY());
+                if (absY < 0.1f) {
+                    float mul = 0.4f + absY * 0.2f;
+                    motion = motion.mul(mul, 1.0f, mul);
+                }
+            } else if (landingBlock instanceof BedBlock) {
+                motion = Vector3f.from(motion.getX(), -motion.getY() * 0.66f, motion.getZ());
+                bounced = true;
+            }
+        }
+
+        // Set motion to 0 if a movement multiplier was used, else set to 0 on each axis with a collision
+        if (movementMultiplier != null) {
+            motion = Vector3f.ZERO;
+        } else {
+            motion = motion.mul(
+                    moveDiff.getX() == 0 ? 1 : 0,
+                    moveDiff.getY() == 0 || bounced ? 1 : 0,
+                    moveDiff.getZ() == 0 ? 1 : 0
+            );
+        }
+
+        // Send the new position to the bedrock client and java server
+        moveVehicle(ctx.centerPos(), onGround);
+        vehicle.setMotion(motion);
+
+        applyBlockCollisionEffects(ctx);
+
+        float velocityMultiplier = getVelocityMultiplier(ctx);
+        vehicle.setMotion(vehicle.getMotion().mul(velocityMultiplier, 1.0f, velocityMultiplier));
+
+        return horizontalCollision;
+    }
+
+    protected boolean isClimbing(VehicleContext ctx) {
+        if (!vehicle.canClimb()) {
+            return false;
+        }
+
+        BlockState blockState = ctx.centerBlock();
+        if (vehicle.getSession().getTagCache().is(BlockTag.CLIMBABLE, blockState.block())) {
+            return true;
+        }
+
+        // Check if the vehicle is in an open trapdoor with a ladder of the same direction under it
+        if (blockState.block() instanceof TrapDoorBlock && blockState.getValue(Properties.OPEN)) {
+            BlockState ladderState = ctx.getBlock(ctx.centerPos().toInt().down());
+            return ladderState.is(Blocks.LADDER) &&
+                    ladderState.getValue(Properties.HORIZONTAL_FACING) == blockState.getValue(Properties.HORIZONTAL_FACING);
+        }
+
+        return false;
+    }
+
+    protected Vector2f normalizeInput(Vector2f input) {
+        float lenSquared = input.lengthSquared();
+        if (lenSquared < 1.0E-7) {
+            return Vector2f.ZERO;
+        } else if (lenSquared > 1.0) {
+            return input.normalize();
+        }
+        return input;
+    }
+
+    protected Vector3f getInputVelocity(VehicleContext ctx, float speed) {
+        Vector2f input = vehicle.getSession().getPlayerEntity().getVehicleInput();
+        input = input.mul(0.98f);
+        input = vehicle.getAdjustedInput(input);
+        input = normalizeInput(input);
+        input = input.mul(speed);
+
+        float yaw = vehicle.getSession().getPlayerEntity().getYaw();
+        float sin = TrigMath.sin(yaw * TrigMath.DEG_TO_RAD);
+        float cos = TrigMath.cos(yaw * TrigMath.DEG_TO_RAD);
+        return Vector3f.from(input.getX() * cos - input.getY() * sin, 0, input.getY() * cos + input.getX() * sin);
+    }
+
+    protected Vector2f getVehicleRotation() {
+        LivingEntity player = vehicle.getSession().getPlayerEntity();
+        return Vector2f.from(player.getYaw(), player.getPitch() * 0.5f);
+    }
+
+    protected void moveVehicle(Vector3d javaPos, boolean isOnGround) {
+        Vector3f bedrockPos = javaPos.toFloat();
+        Vector2f rotation = getVehicleRotation();
+
+        MoveEntityDeltaPacket moveEntityDeltaPacket = new MoveEntityDeltaPacket();
+        moveEntityDeltaPacket.setRuntimeEntityId(vehicle.getGeyserId());
+
+        if (isOnGround) {
+            moveEntityDeltaPacket.getFlags().add(MoveEntityDeltaPacket.Flag.ON_GROUND);
+        }
+        vehicle.setOnGround(isOnGround);
+
+        if (vehicle.getPosition().getX() != bedrockPos.getX()) {
+            moveEntityDeltaPacket.getFlags().add(MoveEntityDeltaPacket.Flag.HAS_X);
+            moveEntityDeltaPacket.setX(bedrockPos.getX());
+        }
+        if (vehicle.getPosition().getY() != bedrockPos.getY()) {
+            moveEntityDeltaPacket.getFlags().add(MoveEntityDeltaPacket.Flag.HAS_Y);
+            moveEntityDeltaPacket.setY(bedrockPos.getY());
+        }
+        if (vehicle.getPosition().getZ() != bedrockPos.getZ()) {
+            moveEntityDeltaPacket.getFlags().add(MoveEntityDeltaPacket.Flag.HAS_Z);
+            moveEntityDeltaPacket.setZ(bedrockPos.getZ());
+        }
+        vehicle.setPosition(bedrockPos);
+
+        if (vehicle.getYaw() != rotation.getX()) {
+            moveEntityDeltaPacket.getFlags().add(MoveEntityDeltaPacket.Flag.HAS_YAW);
+            moveEntityDeltaPacket.setYaw(rotation.getX());
+            vehicle.setYaw(rotation.getX());
+        }
+        if (vehicle.getPitch() != rotation.getY()) {
+            moveEntityDeltaPacket.getFlags().add(MoveEntityDeltaPacket.Flag.HAS_PITCH);
+            moveEntityDeltaPacket.setPitch(rotation.getY());
+            vehicle.setPitch(rotation.getY());
+        }
+        if (vehicle.getHeadYaw() != rotation.getX()) { // Same as yaw
+            moveEntityDeltaPacket.getFlags().add(MoveEntityDeltaPacket.Flag.HAS_HEAD_YAW);
+            moveEntityDeltaPacket.setHeadYaw(rotation.getX());
+            vehicle.setHeadYaw(rotation.getX());
+        }
+
+        if (!moveEntityDeltaPacket.getFlags().isEmpty()) {
+            vehicle.getSession().sendUpstreamPacket(moveEntityDeltaPacket);
+        }
+
+        ServerboundMoveVehiclePacket moveVehiclePacket = new ServerboundMoveVehiclePacket(javaPos.getX(), javaPos.getY(), javaPos.getZ(), rotation.getX(), rotation.getY());
+        vehicle.getSession().sendDownstreamPacket(moveVehiclePacket);
+        vehicle.getSession().setLastVehicleMoveTimestamp(System.currentTimeMillis());
+    }
+
+    protected double getGravity() {
+        if (!vehicle.getFlag(EntityFlag.HAS_GRAVITY)) {
+            return 0;
+        }
+
+        if (vehicle.getMotion().getY() <= 0 && effectSlowFalling) {
+            return Math.min(0.01, this.gravity);
+        }
+
+        return this.gravity;
+    }
+
+    protected @Nullable Vector3i getSupportingBlockPos(VehicleContext ctx) {
+        Vector3i result = null;
+
+        if (vehicle.isOnGround()) {
+            BoundingBox box = boundingBox.clone();
+            box.extend(0, -1.0E-6, 0); // Extend slightly down
+
+            Vector3i min = box.getMin().toInt();
+            Vector3i max = box.getMax().toInt();
+
+            // Use minY as maxY
+            BlockPositionIterator iter = BlockPositionIterator.fromMinMax(min.getX(), min.getY(), min.getZ(), max.getX(), min.getY(), max.getZ());
+
+            double minDistance = Double.MAX_VALUE;
+            for (iter.reset(); iter.hasNext(); iter.next()) {
+                Vector3i blockPos = Vector3i.from(iter.getX(), iter.getY(), iter.getZ());
+                int blockId = ctx.getBlockId(iter);
+
+                BlockCollision blockCollision;
+                if (vehicle.canWalkOnLava()) {
+                    blockCollision = vehicle.getSession().getCollisionManager().getCollisionLavaWalking(blockId, blockPos.getY(), boundingBox);
+                } else {
+                    blockCollision = BlockUtils.getCollision(blockId);
+                }
+
+                if (blockCollision != null && blockCollision.checkIntersection(blockPos, box)) {
+                    double distance = ctx.centerPos().distanceSquared(blockPos.toDouble().add(0.5f, 0.5f, 0.5f));
+                    if (distance <= minDistance) {
+                        minDistance = distance;
+                        result = blockPos;
+                    }
+                }
+            }
+        }
+
+        return result;
+    }
+
+    protected Vector3i getVelocityAffectingPos(VehicleContext ctx) {
+        Vector3i blockPos = getSupportingBlockPos(ctx);
+        if (blockPos != null) {
+            return Vector3i.from(blockPos.getX(), Math.floor(ctx.centerPos().getY() - 0.500001f), blockPos.getZ());
+        } else {
+            return ctx.centerPos().sub(0, 0.500001f, 0).toInt();
+        }
+    }
+
+    protected float getVelocityMultiplier(VehicleContext ctx) {
+        Block block = ctx.centerBlock().block();
+        if (block == Blocks.WATER || block == Blocks.BUBBLE_COLUMN) {
+            return 1.0f;
+        }
+
+        if (block == Blocks.SOUL_SAND || block == Blocks.HONEY_BLOCK) {
+            return 0.4f;
+        }
+
+        block = ctx.velocityAffectingBlock().block();
+        if (block == Blocks.SOUL_SAND || block == Blocks.HONEY_BLOCK) {
+            return 0.4f;
+        }
+
+        return 1.0f;
+    }
+
+    protected float getJumpVelocityMultiplier(VehicleContext ctx) {
+        Block block = ctx.centerBlock().block();
+        if (block == Blocks.HONEY_BLOCK) {
+            return 0.5f;
+        }
+
+        block = ctx.velocityAffectingBlock().block();
+        if (block == Blocks.HONEY_BLOCK) {
+            return 0.5f;
+        }
+
+        return 1.0f;
+    }
+
+    protected class VehicleContext {
+        private Vector3d centerPos;
+        private BlockState centerBlock;
+        private BlockState velocityAffectingBlock;
+        private BlockPositionIterator blockIter;
+        private int[] blocks;
+
+        protected void loadSurroundingBlocks() {
+            BoundingBox box = boundingBox.clone();
+            box.expand(2);
+
+            Vector3i min = box.getMin().toInt();
+            Vector3i max = box.getMax().toInt();
+            this.blockIter = BlockPositionIterator.fromMinMax(min.getX(), min.getY(), min.getZ(), max.getX(), max.getY(), max.getZ());
+            this.blocks = vehicle.getSession().getGeyser().getWorldManager().getBlocksAt(vehicle.getSession(), this.blockIter);
+
+            this.centerPos = boundingBox.getBottomCenter();
+            this.centerBlock = getBlock(this.centerPos.toInt());
+            this.velocityAffectingBlock = null;
+        }
+
+        protected Vector3d centerPos() {
+            return this.centerPos;
+        }
+
+        protected BlockState centerBlock() {
+            return this.centerBlock;
+        }
+
+        protected BlockState velocityAffectingBlock() {
+            if (this.velocityAffectingBlock == null) {
+                this.velocityAffectingBlock = getBlock(getVelocityAffectingPos(this));
+            }
+
+            return this.velocityAffectingBlock;
+        }
+
+        protected int getBlockId(int x, int y, int z) {
+            int index = this.blockIter.getIndex(x, y, z);
+            if (index == -1) {
+                vehicle.getSession().getGeyser().getLogger().debug("[client-vehicle] Block cache miss");
+                return vehicle.getSession().getGeyser().getWorldManager().getBlockAt(vehicle.getSession(), x, y, z);
+            }
+
+            return blocks[index];
+        }
+
+        protected int getBlockId(Vector3i pos) {
+            return getBlockId(pos.getX(), pos.getY(), pos.getZ());
+        }
+
+        protected int getBlockId(BlockPositionIterator iter) {
+            return getBlockId(iter.getX(), iter.getY(), iter.getZ());
+        }
+
+        protected BlockState getBlock(int x, int y, int z) {
+            return BlockState.of(getBlockId(x, y, z));
+        }
+
+        protected BlockState getBlock(Vector3i pos) {
+            return BlockState.of(getBlockId(pos.getX(), pos.getY(), pos.getZ()));
+        }
+
+        protected BlockState getBlock(BlockPositionIterator iter) {
+            return BlockState.of(getBlockId(iter.getX(), iter.getY(), iter.getZ()));
+        }
+    }
+}
diff --git a/core/src/main/java/org/geysermc/geyser/inventory/PlayerInventory.java b/core/src/main/java/org/geysermc/geyser/inventory/PlayerInventory.java
index 9bef4b08e5bc68287e938089283702f9d14a92d2..4f2408c777ca19fe2f78cfaf225981a56e5adc9b 100644
--- a/core/src/main/java/org/geysermc/geyser/inventory/PlayerInventory.java
+++ b/core/src/main/java/org/geysermc/geyser/inventory/PlayerInventory.java
@@ -29,6 +29,7 @@ import lombok.Getter;
 import lombok.Setter;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.geysermc.geyser.GeyserImpl;
+import org.geysermc.geyser.item.type.Item;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.mcprotocollib.protocol.data.game.entity.player.Hand;
 import org.jetbrains.annotations.Range;
@@ -61,6 +62,16 @@ public class PlayerInventory extends Inventory {
         cursor = newCursor;
     }
 
+    /**
+     * Checks if the player is holding the specified item in either hand
+     *
+     * @param item The item to look for
+     * @return If the player is holding the item in either hand
+     */
+    public boolean isHolding(@NonNull Item item) {
+        return getItemInHand().asItem() == item || getOffhand().asItem() == item;
+    }
+
     public GeyserItemStack getItemInHand(@NonNull Hand hand) {
         return hand == Hand.OFF_HAND ? getOffhand() : getItemInHand();
     }
diff --git a/core/src/main/java/org/geysermc/geyser/level/JavaDimension.java b/core/src/main/java/org/geysermc/geyser/level/JavaDimension.java
index 6112dc6cfdeda6b68b5130e4a987287cbb0c2480..33e479002b75e3e04a4898f9a5d00f16a5f84c26 100644
--- a/core/src/main/java/org/geysermc/geyser/level/JavaDimension.java
+++ b/core/src/main/java/org/geysermc/geyser/level/JavaDimension.java
@@ -32,8 +32,10 @@ import org.geysermc.mcprotocollib.protocol.data.game.RegistryEntry;
  * Represents the information we store from the current Java dimension
  * @param piglinSafe Whether piglins and hoglins are safe from conversion in this dimension.
  *      This controls if they have the shaking effect applied in the dimension.
+ * @param ultrawarm If this dimension is ultrawarm.
+ *      Used when calculating movement in lava for client-side vehicles.
  */
-public record JavaDimension(int minY, int maxY, boolean piglinSafe, double worldCoordinateScale) {
+public record JavaDimension(int minY, int maxY, boolean piglinSafe, boolean ultrawarm, double worldCoordinateScale) {
 
     public static JavaDimension read(RegistryEntry entry) {
         NbtMap dimension = entry.getData();
@@ -43,9 +45,11 @@ public record JavaDimension(int minY, int maxY, boolean piglinSafe, double world
 
         // Set if piglins/hoglins should shake
         boolean piglinSafe = dimension.getBoolean("piglin_safe");
+        // Entities in lava move faster in ultrawarm dimensions
+        boolean ultrawarm = dimension.getBoolean("ultrawarm");
         // Load world coordinate scale for the world border
         double coordinateScale = dimension.getDouble("coordinate_scale");
 
-        return new JavaDimension(minY, maxY, piglinSafe, coordinateScale);
+        return new JavaDimension(minY, maxY, piglinSafe, ultrawarm, coordinateScale);
     }
 }
diff --git a/core/src/main/java/org/geysermc/geyser/level/block/BlockStateValues.java b/core/src/main/java/org/geysermc/geyser/level/block/BlockStateValues.java
index 01e95fc7aabe8459c8a714639688ba21ca41f53c..36e437026a1e145617a1c4b6164746694b004f0f 100644
--- a/core/src/main/java/org/geysermc/geyser/level/block/BlockStateValues.java
+++ b/core/src/main/java/org/geysermc/geyser/level/block/BlockStateValues.java
@@ -36,7 +36,7 @@ import org.geysermc.geyser.registry.BlockRegistries;
  * Used for block entities if the Java block state contains Bedrock block information.
  */
 public final class BlockStateValues {
-    public static final int NUM_WATER_LEVELS = 9;
+    public static final int NUM_FLUID_LEVELS = 9;
 
     /**
      * Checks if a block sticks to other blocks
@@ -99,6 +99,25 @@ public final class BlockStateValues {
         };
     }
 
+    /**
+     * Get the type of fluid from the block state, including waterlogged blocks.
+     *
+     * @param state BlockState of the block
+     * @return The type of fluid
+     */
+    public static Fluid getFluid(int state) {
+        BlockState blockState = BlockState.of(state);
+        if (blockState.is(Blocks.WATER) || BlockRegistries.WATERLOGGED.get().get(state)) {
+            return Fluid.WATER;
+        }
+
+        if (blockState.is(Blocks.LAVA)) {
+            return Fluid.LAVA;
+        }
+
+        return Fluid.EMPTY;
+    }
+
     /**
      * Get the level of water from the block state.
      *
@@ -127,7 +146,7 @@ public final class BlockStateValues {
             waterLevel = 0;
         }
         if (waterLevel >= 0) {
-            double waterHeight = 1 - (waterLevel + 1) / ((double) NUM_WATER_LEVELS);
+            double waterHeight = 1 - (waterLevel + 1) / ((double) NUM_FLUID_LEVELS);
             // Falling water is a full block
             if (waterLevel >= 8) {
                 waterHeight = 1;
@@ -137,6 +156,39 @@ public final class BlockStateValues {
         return -1;
     }
 
+    /**
+     * Get the level of lava from the block state.
+     *
+     * @param state BlockState of the block
+     * @return The lava level or -1 if the block isn't lava
+     */
+    public static int getLavaLevel(int state) {
+        BlockState blockState = BlockState.of(state);
+        if (!blockState.is(Blocks.LAVA)) {
+            return -1;
+        }
+        return blockState.getValue(Properties.LEVEL);
+    }
+
+    /**
+     * Get the height of lava from the block state
+     *
+     * @param state BlockState of the block
+     * @return The lava height or -1 if the block does not contain lava
+     */
+    public static double getLavaHeight(int state) {
+        int lavaLevel = BlockStateValues.getLavaLevel(state);
+        if (lavaLevel >= 0) {
+            double lavaHeight = 1 - (lavaLevel + 1) / ((double) NUM_FLUID_LEVELS);
+            // Falling lava is a full block
+            if (lavaLevel >= 8) {
+                lavaHeight = 1;
+            }
+            return lavaHeight;
+        }
+        return -1;
+    }
+
     /**
      * Get the slipperiness of a block.
      * This is used in ItemEntity to calculate the friction on an item as it slides across the ground
diff --git a/core/src/main/java/org/geysermc/geyser/level/block/Fluid.java b/core/src/main/java/org/geysermc/geyser/level/block/Fluid.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9693bbf466200c94729bc0a244cf22b1c1bb8c0
--- /dev/null
+++ b/core/src/main/java/org/geysermc/geyser/level/block/Fluid.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2019-2023 GeyserMC. http://geysermc.org
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * @author GeyserMC
+ * @link https://github.com/GeyserMC/Geyser
+ */
+
+package org.geysermc.geyser.level.block;
+
+public enum Fluid {
+    WATER,
+    LAVA,
+    EMPTY
+}
diff --git a/core/src/main/java/org/geysermc/geyser/level/physics/BoundingBox.java b/core/src/main/java/org/geysermc/geyser/level/physics/BoundingBox.java
index b1a93d8eeb9d3aa2107d8eb776ffeaf014c80fcd..c4245964b9d5073bdacf3482319e05ee9c33da9f 100644
--- a/core/src/main/java/org/geysermc/geyser/level/physics/BoundingBox.java
+++ b/core/src/main/java/org/geysermc/geyser/level/physics/BoundingBox.java
@@ -33,6 +33,8 @@ import org.cloudburstmc.math.vector.Vector3d;
 @Data
 @AllArgsConstructor
 public class BoundingBox implements Cloneable {
+    private static final double EPSILON = 1.0E-7;
+
     private double middleX;
     private double middleY;
     private double middleZ;
@@ -57,10 +59,24 @@ public class BoundingBox implements Cloneable {
         sizeZ += Math.abs(z);
     }
 
+    public void expand(double x, double y, double z) {
+        sizeX += x;
+        sizeY += y;
+        sizeZ += z;
+    }
+
+    public void translate(Vector3d translate) {
+        translate(translate.getX(), translate.getY(), translate.getZ());
+    }
+
     public void extend(Vector3d extend) {
         extend(extend.getX(), extend.getY(), extend.getZ());
     }
 
+    public void expand(double expand) {
+        expand(expand, expand, expand);
+    }
+
     public boolean checkIntersection(double offsetX, double offsetY, double offsetZ, BoundingBox otherBox) {
         return (Math.abs((middleX + offsetX) - otherBox.getMiddleX()) * 2 < (sizeX + otherBox.getSizeX())) &&
                 (Math.abs((middleY + offsetY) - otherBox.getMiddleY()) * 2 < (sizeY + otherBox.getSizeY())) &&
@@ -91,9 +107,9 @@ public class BoundingBox implements Cloneable {
 
     private boolean checkOverlapInAxis(double xOffset, double yOffset, double zOffset, BoundingBox otherBox, Axis axis) {
         return switch (axis) {
-            case X -> Math.abs((middleX + xOffset) - otherBox.getMiddleX()) * 2 < (sizeX + otherBox.getSizeX());
-            case Y -> Math.abs((middleY + yOffset) - otherBox.getMiddleY()) * 2 < (sizeY + otherBox.getSizeY());
-            case Z -> Math.abs((middleZ + zOffset) - otherBox.getMiddleZ()) * 2 < (sizeZ + otherBox.getSizeZ());
+            case X -> (sizeX + otherBox.getSizeX()) - Math.abs((middleX + xOffset) - otherBox.getMiddleX()) * 2 > EPSILON;
+            case Y -> (sizeY + otherBox.getSizeY()) - Math.abs((middleY + yOffset) - otherBox.getMiddleY()) * 2 > EPSILON;
+            case Z -> (sizeZ + otherBox.getSizeZ()) - Math.abs((middleZ + zOffset) - otherBox.getMiddleZ()) * 2 > EPSILON;
         };
     }
 
diff --git a/core/src/main/java/org/geysermc/geyser/level/physics/CollisionManager.java b/core/src/main/java/org/geysermc/geyser/level/physics/CollisionManager.java
index 2be4e7a385a5afc49bd2502b85df45a3d94f4bdb..a4fdb2e7c311391be759b5148a83faba88054b4d 100644
--- a/core/src/main/java/org/geysermc/geyser/level/physics/CollisionManager.java
+++ b/core/src/main/java/org/geysermc/geyser/level/physics/CollisionManager.java
@@ -45,7 +45,9 @@ import org.geysermc.geyser.level.block.type.BlockState;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.session.cache.PistonCache;
 import org.geysermc.geyser.translator.collision.BlockCollision;
+import org.geysermc.geyser.translator.collision.OtherCollision;
 import org.geysermc.geyser.translator.collision.ScaffoldingCollision;
+import org.geysermc.geyser.translator.collision.SolidCollision;
 import org.geysermc.geyser.util.BlockUtils;
 
 import java.text.DecimalFormat;
@@ -53,6 +55,8 @@ import java.text.DecimalFormatSymbols;
 import java.util.Locale;
 
 public class CollisionManager {
+    public static final BlockCollision SOLID_COLLISION = new SolidCollision(null);
+    public static final BlockCollision FLUID_COLLISION = new OtherCollision(new BoundingBox[]{new BoundingBox(0.5, 0.25, 0.5, 1, 0.5, 1)});
 
     private final GeyserSession session;
 
@@ -268,13 +272,13 @@ public class CollisionManager {
         if (teleported || (!checkWorld && session.getPistonCache().getPistons().isEmpty())) { // There is nothing to check
             return movement;
         }
-        return correctMovement(movement, playerBoundingBox, session.getPlayerEntity().isOnGround(), PLAYER_STEP_UP, checkWorld);
+        return correctMovement(movement, playerBoundingBox, session.getPlayerEntity().isOnGround(), PLAYER_STEP_UP, checkWorld, false);
     }
 
-    public Vector3d correctMovement(Vector3d movement, BoundingBox boundingBox, boolean onGround, double stepUp, boolean checkWorld) {
+    public Vector3d correctMovement(Vector3d movement, BoundingBox boundingBox, boolean onGround, double stepUp, boolean checkWorld, boolean walkOnLava) {
         Vector3d adjustedMovement = movement;
         if (!movement.equals(Vector3d.ZERO)) {
-            adjustedMovement = correctMovementForCollisions(movement, boundingBox, checkWorld);
+            adjustedMovement = correctMovementForCollisions(movement, boundingBox, checkWorld, walkOnLava);
         }
 
         boolean verticalCollision = adjustedMovement.getY() != movement.getY();
@@ -283,26 +287,27 @@ public class CollisionManager {
         onGround = onGround || (verticalCollision && falling);
         if (onGround && horizontalCollision) {
             Vector3d horizontalMovement = Vector3d.from(movement.getX(), 0, movement.getZ());
-            Vector3d stepUpMovement = correctMovementForCollisions(horizontalMovement.up(stepUp), boundingBox, checkWorld);
+            Vector3d stepUpMovement = correctMovementForCollisions(horizontalMovement.up(stepUp), boundingBox, checkWorld, walkOnLava);
 
             BoundingBox stretchedBoundingBox = boundingBox.clone();
             stretchedBoundingBox.extend(horizontalMovement);
-            double maxStepUp = correctMovementForCollisions(Vector3d.from(0, stepUp, 0), stretchedBoundingBox, checkWorld).getY();
+            double maxStepUp = correctMovementForCollisions(Vector3d.from(0, stepUp, 0), stretchedBoundingBox, checkWorld, walkOnLava).getY();
             if (maxStepUp < stepUp) { // The player collided with a block above them
-                boundingBox.translate(0, maxStepUp, 0);
-                Vector3d adjustedStepUpMovement = correctMovementForCollisions(horizontalMovement, boundingBox, checkWorld);
-                boundingBox.translate(0, -maxStepUp, 0);
+                BoundingBox stepUpBoundingBox = boundingBox.clone();
+                stepUpBoundingBox.translate(0, maxStepUp, 0);
 
+                Vector3d adjustedStepUpMovement = correctMovementForCollisions(horizontalMovement, stepUpBoundingBox, checkWorld, walkOnLava);
                 if (squaredHorizontalLength(adjustedStepUpMovement) > squaredHorizontalLength(stepUpMovement)) {
                     stepUpMovement = adjustedStepUpMovement.up(maxStepUp);
                 }
             }
 
             if (squaredHorizontalLength(stepUpMovement) > squaredHorizontalLength(adjustedMovement)) {
-                boundingBox.translate(stepUpMovement.getX(), stepUpMovement.getY(), stepUpMovement.getZ());
+                BoundingBox stepUpBoundingBox = boundingBox.clone();
+                stepUpBoundingBox.translate(stepUpMovement.getX(), stepUpMovement.getY(), stepUpMovement.getZ());
+
                 // Apply the player's remaining vertical movement
-                double verticalMovement = correctMovementForCollisions(Vector3d.from(0, movement.getY() - stepUpMovement.getY(), 0), boundingBox, checkWorld).getY();
-                boundingBox.translate(-stepUpMovement.getX(), -stepUpMovement.getY(), -stepUpMovement.getZ());
+                double verticalMovement = correctMovementForCollisions(Vector3d.from(0, movement.getY() - stepUpMovement.getY(), 0), stepUpBoundingBox, checkWorld, walkOnLava).getY();
 
                 stepUpMovement = stepUpMovement.up(verticalMovement);
                 adjustedMovement = stepUpMovement;
@@ -315,43 +320,53 @@ public class CollisionManager {
         return vector.getX() * vector.getX() + vector.getZ() * vector.getZ();
     }
 
-    private Vector3d correctMovementForCollisions(Vector3d movement, BoundingBox boundingBox, boolean checkWorld) {
+    private Vector3d correctMovementForCollisions(Vector3d movement, BoundingBox boundingBox, boolean checkWorld, boolean walkOnLava) {
         double movementX = movement.getX();
         double movementY = movement.getY();
         double movementZ = movement.getZ();
 
+        // Position might change slightly due to floating point error
+        double originalX = boundingBox.getMiddleX();
+        double originalY = boundingBox.getMiddleY();
+        double originalZ = boundingBox.getMiddleZ();
+
         BoundingBox movementBoundingBox = boundingBox.clone();
         movementBoundingBox.extend(movement);
         BlockPositionIterator iter = collidableBlocksIterator(movementBoundingBox);
         if (Math.abs(movementY) > CollisionManager.COLLISION_TOLERANCE) {
-            movementY = computeCollisionOffset(boundingBox, Axis.Y, movementY, iter, checkWorld);
+            movementY = computeCollisionOffset(boundingBox, Axis.Y, movementY, iter, checkWorld, walkOnLava);
             boundingBox.translate(0, movementY, 0);
         }
         boolean checkZFirst = Math.abs(movementZ) > Math.abs(movementX);
         if (checkZFirst && Math.abs(movementZ) > CollisionManager.COLLISION_TOLERANCE) {
-            movementZ = computeCollisionOffset(boundingBox, Axis.Z, movementZ, iter, checkWorld);
+            movementZ = computeCollisionOffset(boundingBox, Axis.Z, movementZ, iter, checkWorld, walkOnLava);
             boundingBox.translate(0, 0, movementZ);
         }
         if (Math.abs(movementX) > CollisionManager.COLLISION_TOLERANCE) {
-            movementX = computeCollisionOffset(boundingBox, Axis.X, movementX, iter, checkWorld);
+            movementX = computeCollisionOffset(boundingBox, Axis.X, movementX, iter, checkWorld, walkOnLava);
             boundingBox.translate(movementX, 0, 0);
         }
         if (!checkZFirst && Math.abs(movementZ) > CollisionManager.COLLISION_TOLERANCE) {
-            movementZ = computeCollisionOffset(boundingBox, Axis.Z, movementZ, iter, checkWorld);
+            movementZ = computeCollisionOffset(boundingBox, Axis.Z, movementZ, iter, checkWorld, walkOnLava);
             boundingBox.translate(0, 0, movementZ);
         }
 
-        boundingBox.translate(-movementX, -movementY, -movementZ);
+        boundingBox.setMiddleX(originalX);
+        boundingBox.setMiddleY(originalY);
+        boundingBox.setMiddleZ(originalZ);
+
         return Vector3d.from(movementX, movementY, movementZ);
     }
 
-    private double computeCollisionOffset(BoundingBox boundingBox, Axis axis, double offset, BlockPositionIterator iter, boolean checkWorld) {
+    private double computeCollisionOffset(BoundingBox boundingBox, Axis axis, double offset, BlockPositionIterator iter, boolean checkWorld, boolean walkOnLava) {
         for (iter.reset(); iter.hasNext(); iter.next()) {
             int x = iter.getX();
             int y = iter.getY();
             int z = iter.getZ();
             if (checkWorld) {
-                BlockCollision blockCollision = BlockUtils.getCollisionAt(session, x, y, z);
+                int blockId = session.getGeyser().getWorldManager().getBlockAt(session, x, y, z);
+
+                BlockCollision blockCollision = walkOnLava ? getCollisionLavaWalking(blockId, y, boundingBox) : BlockUtils.getCollision(blockId);
                 if (blockCollision != null && !(blockCollision instanceof ScaffoldingCollision)) {
                     offset = blockCollision.computeCollisionOffset(x, y, z, boundingBox, axis, offset);
                 }
@@ -364,6 +379,16 @@ public class CollisionManager {
         return offset;
     }
 
+    /**
+     * @return the block collision appropriate for entities that can walk on lava (Strider)
+     */
+    public BlockCollision getCollisionLavaWalking(int blockId, int blockY, BoundingBox boundingBox) {
+        if (BlockStateValues.getLavaLevel(blockId) == 0 && FLUID_COLLISION.isBelow(blockY, boundingBox)) {
+            return FLUID_COLLISION;
+        }
+        return BlockUtils.getCollision(blockId);
+    }
+
     /**
      * @return true if the block located at the player's floor position plus 1 would intersect with the player,
      * were they not sneaking
@@ -417,7 +442,7 @@ public class CollisionManager {
         double eyeY = playerBoundingBox.getMiddleY() - playerBoundingBox.getSizeY() / 2d + session.getEyeHeight();
         double eyeZ = playerBoundingBox.getMiddleZ();
 
-        eyeY -= 1 / ((double) BlockStateValues.NUM_WATER_LEVELS); // Subtract the height of one water layer
+        eyeY -= 1 / ((double) BlockStateValues.NUM_FLUID_LEVELS); // Subtract the height of one water layer
         int blockID = session.getGeyser().getWorldManager().getBlockAt(session, GenericMath.floor(eyeX), GenericMath.floor(eyeY), GenericMath.floor(eyeZ));
         double waterHeight = BlockStateValues.getWaterHeight(blockID);
 
diff --git a/core/src/main/java/org/geysermc/geyser/level/physics/Direction.java b/core/src/main/java/org/geysermc/geyser/level/physics/Direction.java
index f14a469990737c38149891fc6a89c4d0633cfcfa..4821734f3fbcab37d3fb5715dc41f51cfc00b5b5 100644
--- a/core/src/main/java/org/geysermc/geyser/level/physics/Direction.java
+++ b/core/src/main/java/org/geysermc/geyser/level/physics/Direction.java
@@ -38,6 +38,7 @@ public enum Direction {
     EAST(4, Vector3i.UNIT_X, Axis.X, org.geysermc.mcprotocollib.protocol.data.game.entity.object.Direction.EAST);
 
     public static final Direction[] VALUES = values();
+    public static final Direction[] HORIZONTAL = new Direction[]{Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST};
 
     private final int reversedId;
     @Getter
diff --git a/core/src/main/java/org/geysermc/geyser/session/GeyserSession.java b/core/src/main/java/org/geysermc/geyser/session/GeyserSession.java
index fc000b95f5ea671678b9e97fefc3577e439d66a1..c2d412939c2b1ab31443c61b476603a391cf569b 100644
--- a/core/src/main/java/org/geysermc/geyser/session/GeyserSession.java
+++ b/core/src/main/java/org/geysermc/geyser/session/GeyserSession.java
@@ -88,6 +88,7 @@ import org.geysermc.geyser.entity.type.Entity;
 import org.geysermc.geyser.entity.type.ItemFrameEntity;
 import org.geysermc.geyser.entity.type.Tickable;
 import org.geysermc.geyser.entity.type.player.SessionPlayerEntity;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.erosion.AbstractGeyserboundPacketHandler;
 import org.geysermc.geyser.erosion.GeyserboundHandshakePacketHandler;
 import org.geysermc.geyser.impl.camera.CameraDefinitions;
@@ -524,6 +525,19 @@ public class GeyserSession implements GeyserConnection, GeyserCommandSource {
      */
     private ScheduledFuture<?> tickThread = null;
 
+    /**
+     * The number of ticks that have elapsed since the start of this session
+     */
+    private int ticks;
+
+    /**
+     * The world time in ticks according to the server
+     * <p>
+     * Note: The TickingStatePacket is currently ignored.
+     */
+    @Setter
+    private long worldTicks;
+
     /**
      * Used to return the player to their original rotation after using an item in BedrockInventoryTransactionTranslator
      */
@@ -1193,6 +1207,10 @@ public class GeyserSession implements GeyserConnection, GeyserCommandSource {
                 isInWorldBorderWarningArea = false;
             }
 
+            Entity vehicle = playerEntity.getVehicle();
+            if (vehicle instanceof ClientVehicle clientVehicle && vehicle.isValid()) {
+                clientVehicle.getVehicleComponent().tickVehicle();
+            }
 
             for (Tickable entity : entityCache.getTickableEntities()) {
                 entity.tick();
@@ -1228,6 +1246,9 @@ public class GeyserSession implements GeyserConnection, GeyserCommandSource {
         } catch (Throwable throwable) {
             throwable.printStackTrace();
         }
+
+        ticks++;
+        worldTicks++;
     }
 
     public void setAuthenticationData(AuthData authData) {
diff --git a/core/src/main/java/org/geysermc/geyser/session/cache/tags/BlockTag.java b/core/src/main/java/org/geysermc/geyser/session/cache/tags/BlockTag.java
index 7017ad55c843c5feb131940dec51b00c62474258..483f8e5efa82b572568a823ebc3122829f7d292c 100644
--- a/core/src/main/java/org/geysermc/geyser/session/cache/tags/BlockTag.java
+++ b/core/src/main/java/org/geysermc/geyser/session/cache/tags/BlockTag.java
@@ -36,7 +36,8 @@ public enum BlockTag {
     SHOVEL_EFFECTIVE("mineable/shovel"),
     NEEDS_STONE_TOOL("needs_stone_tool"),
     NEEDS_IRON_TOOL("needs_iron_tool"),
-    NEEDS_DIAMOND_TOOL("needs_diamond_tool");
+    NEEDS_DIAMOND_TOOL("needs_diamond_tool"),
+    CLIMBABLE("climbable");
     
     BlockTag(String identifier) {
         register(identifier, this);
diff --git a/core/src/main/java/org/geysermc/geyser/translator/collision/BlockCollision.java b/core/src/main/java/org/geysermc/geyser/translator/collision/BlockCollision.java
index 2481028a44839fa9b6ea93337600ab54be1256be..f47ac2abe14766f294e6e2922e51db779f755dcb 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/collision/BlockCollision.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/collision/BlockCollision.java
@@ -166,4 +166,15 @@ public class BlockCollision {
         }
         return offset;
     }
+
+    public boolean isBelow(double y, BoundingBox boundingBox) {
+        double minY = boundingBox.getMiddleY() - boundingBox.getSizeY() / 2;
+        for (BoundingBox b : boundingBoxes) {
+            double offset = y + b.getMiddleY() + b.getSizeY() / 2 - minY;
+            if (offset > CollisionManager.COLLISION_TOLERANCE) {
+                return false;
+            }
+        }
+        return true;
+    }
 }
\ No newline at end of file
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/BedrockPlayerInputTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/BedrockPlayerInputTranslator.java
index beb724ffbea91073abd2cd4ac7e1d4831f8b3f52..1498c21841c22da48a73904f8b69101f863461e8 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/BedrockPlayerInputTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/BedrockPlayerInputTranslator.java
@@ -52,6 +52,8 @@ public class BedrockPlayerInputTranslator extends PacketTranslator<PlayerInputPa
 
         session.sendDownstreamGamePacket(playerInputPacket);
 
+        session.getPlayerEntity().setVehicleInput(packet.getInputMotion());
+
         // Bedrock only sends movement vehicle packets while moving
         // This allows horses to take damage while standing on magma
         Entity vehicle = session.getPlayerEntity().getVehicle();
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/entity/player/BedrockRiderJumpTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/entity/player/BedrockRiderJumpTranslator.java
index 76b95103e0588d6026aeb6933f9051265a8726a4..17668e0003498fdcccf44ca9f443cc4a9fa773c5 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/entity/player/BedrockRiderJumpTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/bedrock/entity/player/BedrockRiderJumpTranslator.java
@@ -38,6 +38,8 @@ import org.geysermc.geyser.translator.protocol.Translator;
 public class BedrockRiderJumpTranslator extends PacketTranslator<RiderJumpPacket> {
     @Override
     public void translate(GeyserSession session, RiderJumpPacket packet) {
+        session.getPlayerEntity().setVehicleJumpStrength(packet.getJumpStrength());
+
         Entity vehicle = session.getPlayerEntity().getVehicle();
         if (vehicle instanceof AbstractHorseEntity) {
             ServerboundPlayerCommandPacket playerCommandPacket = new ServerboundPlayerCommandPacket(vehicle.getEntityId(), PlayerState.START_HORSE_JUMP, packet.getJumpStrength());
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/JavaRespawnTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/JavaRespawnTranslator.java
index fe0868253afca298458f8e5f2536b146a994096b..966d147637a6c0fc1c0eb5c4275bcadb2a366fa5 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/JavaRespawnTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/JavaRespawnTranslator.java
@@ -100,6 +100,7 @@ public class JavaRespawnTranslator extends PacketTranslator<ClientboundRespawnPa
                 DimensionUtils.switchDimension(session, fakeDim);
             }
             session.setWorldName(spawnInfo.getWorldName());
+            session.setWorldTicks(0);
             DimensionUtils.switchDimension(session, newDimension);
 
             ChunkUtils.loadDimension(session);
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaMoveVehicleTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaMoveVehicleTranslator.java
index 111b72c4fce0c5d75cad445b24d00f17854f3584..1f18d4d2f2e93840250a150fc772952460085c8e 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaMoveVehicleTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaMoveVehicleTranslator.java
@@ -28,6 +28,7 @@ package org.geysermc.geyser.translator.protocol.java.entity;
 import org.geysermc.mcprotocollib.protocol.packet.ingame.clientbound.entity.ClientboundMoveVehiclePacket;
 import org.cloudburstmc.math.vector.Vector3f;
 import org.geysermc.geyser.entity.type.Entity;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.translator.protocol.PacketTranslator;
 import org.geysermc.geyser.translator.protocol.Translator;
@@ -40,6 +41,10 @@ public class JavaMoveVehicleTranslator extends PacketTranslator<ClientboundMoveV
         Entity entity = session.getPlayerEntity().getVehicle();
         if (entity == null) return;
 
+        if (entity instanceof ClientVehicle clientVehicle) {
+            clientVehicle.getVehicleComponent().moveAbsolute(packet.getX(), packet.getY(), packet.getZ());
+        }
+
         entity.moveAbsolute(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), false, true);
     }
 }
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaRemoveMobEffectTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaRemoveMobEffectTranslator.java
index dafa5aec1d091122d0c485f39b125ee0298be67e..0230d8c235d68972d361d766fde855377b9b5b9b 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaRemoveMobEffectTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaRemoveMobEffectTranslator.java
@@ -28,6 +28,7 @@ package org.geysermc.geyser.translator.protocol.java.entity;
 import org.geysermc.mcprotocollib.protocol.packet.ingame.clientbound.entity.ClientboundRemoveMobEffectPacket;
 import org.cloudburstmc.protocol.bedrock.packet.MobEffectPacket;
 import org.geysermc.geyser.entity.type.Entity;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.translator.protocol.PacketTranslator;
 import org.geysermc.geyser.translator.protocol.Translator;
@@ -39,11 +40,15 @@ public class JavaRemoveMobEffectTranslator extends PacketTranslator<ClientboundR
     @Override
     public void translate(GeyserSession session, ClientboundRemoveMobEffectPacket packet) {
         Entity entity  = session.getEntityCache().getEntityByJavaId(packet.getEntityId());
+        if (entity == null) {
+            return;
+        }
+
         if (entity == session.getPlayerEntity()) {
             session.getEffectCache().removeEffect(packet.getEffect());
+        } else if (entity instanceof ClientVehicle clientVehicle) {
+            clientVehicle.getVehicleComponent().removeEffect(packet.getEffect());
         }
-        if (entity == null)
-            return;
 
         MobEffectPacket mobEffectPacket = new MobEffectPacket();
         mobEffectPacket.setEvent(MobEffectPacket.Event.REMOVE);
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaSetPassengersTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaSetPassengersTranslator.java
index 9895a248c29f69870664cbc8905da42343269344..865ca0464131055d7dddf7f42d462eac24af817f 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaSetPassengersTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaSetPassengersTranslator.java
@@ -30,6 +30,7 @@ import org.cloudburstmc.protocol.bedrock.data.entity.EntityLinkData;
 import org.cloudburstmc.protocol.bedrock.packet.SetEntityLinkPacket;
 import org.geysermc.geyser.entity.EntityDefinitions;
 import org.geysermc.geyser.entity.type.Entity;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.translator.protocol.PacketTranslator;
 import org.geysermc.geyser.translator.protocol.Translator;
@@ -55,6 +56,10 @@ public class JavaSetPassengersTranslator extends PacketTranslator<ClientboundSet
                 session.getPlayerEntity().setVehicle(entity);
                 // We need to confirm teleports before entering a vehicle, or else we will likely exit right out
                 session.confirmTeleport(passenger.getPosition().sub(0, EntityDefinitions.PLAYER.offset(), 0).toDouble());
+
+                if (entity instanceof ClientVehicle clientVehicle) {
+                    clientVehicle.getVehicleComponent().onMount();
+                }
             }
             if (passenger == null) {
                 // Can occur if the passenger is outside the client's tracking range
@@ -100,6 +105,10 @@ public class JavaSetPassengersTranslator extends PacketTranslator<ClientboundSet
                         // as of Java 1.19.3, but the scheduled future checks for the vehicle being null anyway.
                         session.getMountVehicleScheduledFuture().cancel(false);
                     }
+
+                    if (entity instanceof ClientVehicle clientVehicle) {
+                        clientVehicle.getVehicleComponent().onDismount();
+                    }
                 }
             }
         }
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaTeleportEntityTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaTeleportEntityTranslator.java
index 8b3a06d7cac879df9455f71e6d31cc70c717d5f3..47c61eb8eaa4a49f689c45dd9fb9c32bc87760cd 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaTeleportEntityTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaTeleportEntityTranslator.java
@@ -28,6 +28,7 @@ package org.geysermc.geyser.translator.protocol.java.entity;
 import org.geysermc.mcprotocollib.protocol.packet.ingame.clientbound.entity.ClientboundTeleportEntityPacket;
 import org.cloudburstmc.math.vector.Vector3f;
 import org.geysermc.geyser.entity.type.Entity;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.translator.protocol.PacketTranslator;
 import org.geysermc.geyser.translator.protocol.Translator;
@@ -40,6 +41,10 @@ public class JavaTeleportEntityTranslator extends PacketTranslator<ClientboundTe
         Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());
         if (entity == null) return;
 
+        if (entity instanceof ClientVehicle clientVehicle) {
+            clientVehicle.getVehicleComponent().moveAbsolute(packet.getX(), packet.getY(), packet.getZ());
+        }
+
         entity.teleport(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), packet.isOnGround());
     }
 }
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaUpdateMobEffectTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaUpdateMobEffectTranslator.java
index 7638df8bebe5629be9185749c5a09d283b85ad97..c44bcb931a369c86793727b9f4e1bff0c42fb0b2 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaUpdateMobEffectTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/entity/JavaUpdateMobEffectTranslator.java
@@ -28,6 +28,7 @@ package org.geysermc.geyser.translator.protocol.java.entity;
 import org.geysermc.mcprotocollib.protocol.packet.ingame.clientbound.entity.ClientboundUpdateMobEffectPacket;
 import org.cloudburstmc.protocol.bedrock.packet.MobEffectPacket;
 import org.geysermc.geyser.entity.type.Entity;
+import org.geysermc.geyser.entity.vehicle.ClientVehicle;
 import org.geysermc.geyser.session.GeyserSession;
 import org.geysermc.geyser.translator.protocol.PacketTranslator;
 import org.geysermc.geyser.translator.protocol.Translator;
@@ -39,13 +40,16 @@ public class JavaUpdateMobEffectTranslator extends PacketTranslator<ClientboundU
     @Override
     public void translate(GeyserSession session, ClientboundUpdateMobEffectPacket packet) {
         Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());
-        if (entity == session.getPlayerEntity()) {
-            session.getEffectCache().setEffect(packet.getEffect(), packet.getAmplifier());
-        }
         if (entity == null) {
             return;
         }
 
+        if (entity == session.getPlayerEntity()) {
+            session.getEffectCache().setEffect(packet.getEffect(), packet.getAmplifier());
+        } else if (entity instanceof ClientVehicle clientVehicle) {
+            clientVehicle.getVehicleComponent().setEffect(packet.getEffect(), packet.getAmplifier());
+        }
+
         int duration = packet.getDuration();
         if (duration < 0) {
             // java edition uses -1 for infinite, but bedrock doesn't have infinite
diff --git a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/level/JavaSetTimeTranslator.java b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/level/JavaSetTimeTranslator.java
index 1e398ad9bbf5a254999ff1064ece13a1a60c6985..43ef0870a05e2ed8e4e03ed743c66db17f8e8a49 100644
--- a/core/src/main/java/org/geysermc/geyser/translator/protocol/java/level/JavaSetTimeTranslator.java
+++ b/core/src/main/java/org/geysermc/geyser/translator/protocol/java/level/JavaSetTimeTranslator.java
@@ -36,6 +36,8 @@ public class JavaSetTimeTranslator extends PacketTranslator<ClientboundSetTimePa
 
     @Override
     public void translate(GeyserSession session, ClientboundSetTimePacket packet) {
+        session.setWorldTicks(packet.getWorldAge());
+
         // Bedrock sends a GameRulesChangedPacket if there is no daylight cycle
         // Java just sends a negative long if there is no daylight cycle
         long time = packet.getTime();
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 9ff1f3afd80678bb6f21f955825dadcc4d6eecc9..1461cd003c1a5f782e0cc5ebcaace1f586ba3ca0 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,7 +1,7 @@
 [versions]
 base-api = "1.0.0-SNAPSHOT"
 cumulus = "1.1.2"
-erosion = "1.1-20240515.191456-1"
+erosion = "1.1-20240521.000109-3"
 events = "1.1-SNAPSHOT"
 jackson = "2.17.0"
 fastutil = "8.5.2"
